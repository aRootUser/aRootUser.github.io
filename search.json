[{"title":"DataNode物理结构","url":"/2019/09/20/2019-9-13/","content":"<Excerpt in index | 首页摘要>\n简单总结下DataNode的物理结构\n<!-- more -->\n分两个方向来讲述DataNode的目录结构\n\n# 一、DataNode磁盘目录结构\n1. 比如datanode上有12个盘，同一个块池目录比如BP-1007908154-10.10.10.10-1533290355162存在于所有的盘上。\n\n\n2. 在HDFS-6482之前，是通过LDir这个类来存放具体的数据块的目录位置。所以存在一个很大的问题就是当由于数据块的数量非常大的时候，由于需要在内存中记录数据块的具体位置，还需要记录对应的subdirs，会对DN造成很大的内存开销。\n> 所以这个Patch的思想是通过两层subdir的方式来存放不同的数据块。具体实现是DatanodeUtil.idToBlockDir()分别根据块池id，取第二和第三个字节位来得到两层的subdir的id。这样只需要在用到的时候计算出相应目录即可。\n\n# 二、副本状态\n1.NameNode副本状态\n```java\n static public enum BlockUCState {\n    //commit状态的块收到DN的块汇报后\n    COMPLETE,\n    //正在写入的数据块，大部分的数据块读可见，对应Replica的状态为RBW\n    UNDER_CONSTRUCTION,\n    //如果客户端写文件超过租约后，如果最后一个数据块处于UNDER_CONSTRUCTION状态，当block恢复开始时，UnderConstruction变为UnderRecovery状态，对应Replica的状态为RUR\n    UNDER_RECOVERY,\n    //客户端每次请求新的数据块时候，比如写文件，都会对上一个数据块进行提交。这个表示客户端已经收到这个数据块的请求了，只是还没有收到DN的块汇报\n    COMMITTED;\n  }\n```\n2.DataNode副本状态\n```java\n//所有副本状态类的父类\n//子类有 FinalizedReplica，ReplicaBeingWritten，ReplicaUnderRecovery，ReplicaWaitingToBeRecovered，ReplicaInPipeline\nabstract public class ReplicaInfo extends Block implements Replica {\n}\n//分别对应于ReplicaState\nstatic public enum ReplicaState {\n    /** Replica is finalized. The state when replica is not modified. */\n    FINALIZED(0),\n    /** Replica is being written to. */\n    RBW(1),\n    /** Replica is waiting to be recovered. */\n    RWR(2),\n    /** Replica is under recovery. */\n    RUR(3),\n    /** Temporary replica: created for replication and relocation only. */\n    TEMPORARY(4);\n}\n```\nRWR: ReplicaWaitingToBeRecovered \n\n1. 如果client挂了之后，RWR状态下的replica将会过期，或者将出现在租约恢复的过程中(将RBW状态的Replica转为RWR)\n1\n1. 在DN重启加载块的时候，会将所有RWR目录下的数据块标记为ReplicaWaitingToBeRecovered，并将其及副本信息一起添加到ReplicaMap中\n\n```java\nclass ReplicaMap{\n  //池id->（块id->副本信息）\n  private final Map<String, Map<Long, ReplicaInfo>> map = new HashMap<String, Map<Long, ReplicaInfo>>();\n}\n```\nFINALIZED: FinalizedReplica\n\n1. 表示这个块已经写入完成了，对所有用户都是可见的，最终DU等统计都是以FinalizedReplica的副本为准\n\nRBW: ReplicaBeingWritten\n\n1. 通常表示一个文件中最后一个正在写入的副本\n\n1. bytesAcked:表示接收到下游ack的bytes数，bytesReserved，block已经接收到的bytes数，包括写入磁盘的和在dn内存中的数据\n\n1. 当datanode向下一个datanode发送的数据块写成功了，并且接收到了下一个datanode的ack时，会通过finalizeBlock()提交这个数据块\n\n1. 在DN重启加载块的时候，会将所有RBW目录下的数据块标记为ReplicaWaitingToBeRecovered\n\nRUR: ReplicaUnderRecovery\n1. 租约恢复时候，任意一个非Temporary状态的副本都有可能转换为RUR状态。\n2. 比如当客户端写文件中途退出时候，为了保证最后一个数据块的数据一致性，NN会通过下发恢复指令，选择一个主节点，最终通过FsDatasetImpl.initReplicaRecovery()对这个数据块进行恢复\n\nTEMPORARY: \n1. 数据对客户端不可见\n2. 当DataNode成功接收了其他DataNode的数据块之后，通过DataSetImpl.createTemporary()创建tmp目录，会将这个状态的副本转换为RBW状态\n\nReplicaInPipeline:\n1. 通过DataSetImpl.createTemporary()创建的副本类型为ReplicaInPipeline类型\n## 各个目录文件的简单总结\n\n- finalized：客户端已经完成写入并提交的数据块\n- rbw：客户端正在写入的\n- tmp：比如当这个副本是Datanode在接收其他Datanode写数据块的请求时在构造BlockReceiver时调用的，即写数据块拷贝的时候，最终调用的入口为DataSetImpl.createTemporary()\n- in_used.lock：在初始化块池时，要根据当前的目录分析当前的状态时，会对这个目录加锁。\n\n# 三、目录结构对应的逻辑结构\n## 1.目录维度\nFsDatasetImpl: 实现了FsDatasetSpi接口，管理DataNode上所有的数据块，一些对数据块的各种操作最终都是要访问这个类\n\nFSVolumeImpl: 管理单个存储目录保存的所有数据块，内部通过CHM维护当前目录下块池ID对应的BlockPoolSlice的映射\n\nFSVolumeList: 维护所有FSVolumeImpl的引用，通过FsVolumeImpl[]的AtomicReference来管理\n\nBlockPoolSlice: 管理一个块池的所有数据块，所有的数据块是通过ReplicaMap这个类来进行管理的，ReplicaMap中通过HashMap<String, Map<Long, ReplicaInfo>>来记录，块池id->（块id->副本信息）\n\nBlockPoolSliceStorage: 一个BlockPoolSliceStorage用来管理名字相同的所有的BlockPoolSlice\n\n\n## 2.功能维度\n每个块池对应于每个BPOfferService，目前一共有41个块池，对应线上41个namespace，BPOfferService内部维护了BPServiceActor的列表，实际和NN进行交互的逻辑都是在BPServiceActor中。\n\nBPOfferService内部还维护了NamespaceInfo的信息，只有当它向NN注册之后才会获取这个信息。\n\n\n# 四、DN启动时两个维度间的交互\n## 1.重启时主要过程\n- 首先DN通过配置文件获取NN的命名空间和对应的通信地址\n- DN根据命名空间的个数创建对应的BPOfferService，并且在每个BPOfferService中创建数量相同的BPServiceActor来维持通信\n- 通过调用BPOfferService.start()方法启动BPOfferService下的所有BPServiceActor\n- BPServerActor和NN进行握手\n- rpc获取NamespaceInfo信息，包含了块池的ID，即BlockPoolID，BP-1007908154-10.10.10.10-1533290355162，还有代码的版本，还有ClusterID，如果失败会sleep一段时间后继续重试。拿到信息后还要进行版本的校验。因为同一组BPActor最终是在BPofferService中的，所以BPofferService只要通过加锁BPOfferService.NamespaceInfo判断是否为空已经初始化过了，来保证一个每个BPofferService中只会进行一次尝试DN初始化操作。\n- 如果这是当前BPofferService第一个启动的Actor，还会进行初始化块池，如果块池已经初始化完成了则会跳过。\n- 向NN进行注册，注册的时候会不断尝试直到成功。\n- 一直执行BPServiceActor.offerService()直到退出- \n- 发送心跳包\n- 计算时间定时发送心跳，首先构造StorageReport\n- StorageReport初始化的时候会通过DataSetImpl获取每块盘下的存储信息\n- 发送心跳包时，除了storageReport还包含DN的DU等情况的一些信息\n- NN接受心跳包\n- Rpc调用sendHeartbeat()\n- 通过datanodeManger来处理心跳，根据dataNode的id获取dataNodeMap中的DatanodeDescriptor\n- 最后通过DatanodeDescriptor.updateHeartbeatState()来更新心跳\n- 每次心跳都会根据report数组来更新这个map，并且把错误的DatanodeStorage从map中移除\n- 更新失败块的状态，normal-->failed 最后对这个DatanodeDescriptor中的map进行修剪\n- NN上还有一个异步的线程定时来检查DatanodeDescriptor坏掉的卷上是否有数据块，如果有则通过blockManager将这些块都移除\n- 处理从NN发送回来的信息\n- 调用BPOfferService.processCommand()方法对命令数组进行处理，根据NN返回的cmds数组执行对应的操作\n\n## 2.块池初始化逻辑 \n主要流程：盘目录的初始化，块池的初始化，数据块的初始化。\n\n具体的过程：\n\n1. DataStorage初始化\n2. DN上的盘目录的初始化\n\n```java\n//具体的盘的信息存放在DataNode.DataStorage中\n//DataStorage extends Storage\npublic abstract class Storage extends StorageInfo {\n//存在已经加载完成的盘的列表\nprotected List<StorageDirectory> storageDirs = new ArrayList<StorageDirectory>();\n//块池的ID到其对应的BlockPoolSliceStorage的映射\nprivate final Map<String, BlockPoolSliceStorage> bpStorageMap = Collections.synchronizedMap(new HashMap<String, BlockPoolSliceStorage>());\n}\n```\n- 初始化DN上的存储目录，即之前通过data.dir配置项获取的\n\n- 遍历保存所有的储存的StorageDirectory方法，调用每个StorageDirectory.analyzeStorage() 进行分析\n\n- 加载某个盘的目录时候会通过系统调用判断这个盘目录是否可存在，是否可写，来得到这个盘的一个状态，同时还会判断hasFinalizedTmp，hasRemovedTmp目录的是否存在来判断当前的是否处于升级状态的某个阶段。通常情况下在加载完这个盘后就是Normal状态，最后会持久化Version文件到本地。当这个目录初始化完成后最终会将其添加到上述的storageDirs中。\n\n```java\nboolean hasPrevious = getPreviousDir().exists();\nboolean hasPreviousTmp = getPreviousTmp().exists();\nboolean hasRemovedTmp = getRemovedTmp().exists();\n//...\nif (hasCurrent)\n          return StorageState.NORMAL;\n```\n- DN中定义的存储目录下对应的块池的初始化\n- 上面加载的都是盘的目录，由于这个块池是存在于所有盘的。所以BlockPoolSliceStorage.recoverTransitionRead()要在每个盘上对应的块池目录调用一次这个方法，(由于BlockPoolSliceStorage也是继承于Storage所以也是有如上两个列表来记录加载完成的目录的信息)，只不过这里对应的盘的列表就变成了对应的块池目录的列表\n\n```java\nfor (StorageLocation dataDir : dataDirs) {\n  //....\n  BlockPoolSliceStorage bpStorage = this.bpStorageMap.get(bpid);\n    if (bpStorage == null) {\n       bpStorage = new BlockPoolSliceStorage( );\n    }\n    bpStorage.recoverTransitionRead( )\n    addBlockPoolStorage(bpid, bpStorage);\n}\n```\n- 构造BlockPoolSliceStorage对象，调用BlockPoolSliceStorage.recoverTransitionRead()对每个块池初始化\n- 块池的初始化和上面的过程类似先analyzeStorage()分析状态，然后根据状态进行恢复，通常重启是normal状态，根据不同的状态执行对应的操作\n- 所以最终块池目录加载完毕后DataStorage.bpStorageMap中会存在所有块池id及其对应BlockPoolSliceStorage的唯一映射。\n- DataSetImpl初始化，通过工厂模式创建\n- 初始化volumes\n```java\n//FsVolumeLis用来存放FsVolumeImpl的结构，好处是checkDirs(), getAvailable()就不需要加锁了\nprivate final AtomicReference<FsVolumeImpl[]> volumes\n```\n- 根据DN的存储目录初始化FsVolumeImpl\n- cas并发的添加到AtomicReference<FsVolumeImpl[]> volumes，checkDirs(), getAvailable()\n- 添加对blockScanner的引用，blockScanner在DN初始化后就已经完成\n- 在volumes添加FsVolumeReference时候会在blockScanner中也添加FsVolumeReference\n- 初始化完毕后开始在FsVolumeLis创建多个线程并发的添加块池\n- 遍历volumes列表调用 FsVolumeImpl.addBlockPool()方法\n- FsVolumeImpl构造BlockPoolSlice 并将其添加到bpSlices 的Map中\n- 首先启动和盘的数量相同的线程并行的加载每个盘下的块池目录，比如初始化每个盘下对应的块池id->BlockPoolSliceStorage的映射。\n- 构造BlockPoolSlice时会创建current，rbw，tmp，等目录\n- 数据块的初始化操作\n- 块池目录加载完成后，启动多个线程对每个盘下的数据块副本进行加。\n\n```java\nList<Thread> replicaAddingThreads = new ArrayList<Thread>();\nfor (final FsVolumeImpl v : volumes.get()) {\n  Thread t = new Thread() {\n    //...\n  }\n  replicaAddingThreads.add(t);\n  t.start();\n}\nfor (Thread t : replicaAddingThreads) {\n  t.join();\n}\n```\n1. 最终通过BlockPoolSlice.addToReplicasMap()在每个传入的ReplicaMap上添加各个目录下的数据块，比如Finalize和rbwDir的数据块。\n1. 最终初始化之后的结果是FsVolumeList这个类中的volumes包含了所有的盘的目录，并且每个FsVolumeImpl中记录了每个目录下的各个块的实例，最终存放在ReplicaMap.Map<String, Map<Long, ReplicaInfo>> map这个map中块池id->（块id->副本信息）\n\n","tags":["hadoop"],"categories":["大数据"]},{"title":"安全检测","url":"/2018/05/03/2018-5-3 /","content":"<Excerpt in index | 首页摘要>\n某比赛要求在施工通过监控对没带安全帽的人进行报警\n<!-- more -->\n先吐槽一下比赛的主办方、给的测试视屏画质极低拍摄极为敷衍、有些人连人眼都无法识别是否带了安全帽、这小小的比赛大概整了整个51假期吧、\n## 简单介绍\n这里主要提供一下思路、传统ssd(高配电脑fater-rcnn走起)+inception3、你可能会问为什么不直接用ssd进行二次训练就好了、我当初也是这么想的这不是很简单么、\n然后我先把视频一帧帧的读取并转化成图像然后手动lable(这里有个问题就是一个图像中有多个人这样训练的时候会不会造成无法收敛？我觉得会有很大的影响)、\n然后训练这个像打了码一样的图片(再次吐槽一下主办方)、结果连人都识别不出来！！！内心极度奔溃、然后就用了独创非主流方法\n## 具体步骤(非主流方法请勿模仿、)\n鉴于之前连人都识别出来的问题、我就直接调用ssd先去除人、然后对有戴和没戴安全帽的进行训练(通过inception3)、然后运行通过ssd的目标检测结果输入到inception3中进行判别\n判别的结果传给之前的显示字符串然后进行输出、下面附上源码(目录与object_detection一致)\n\n```python\n#视频的读取得到识别物体后显示出来\nimport os\nimport cv2\nimport time\nimport numpy as np\nimport tensorflow as tf\n\nfrom utils.app_utils import FPS\nfrom object_detection.utils import label_map_util\nfrom object_detection.utils import visualization_utils as vis_util\n\nCWD_PATH = os.getcwd()\n\nMODEL_NAME = 'ssd_mobilenet_v1_coco_11_06_2017'\nPATH_TO_CKPT = os.path.join(CWD_PATH, 'object_detection', MODEL_NAME, 'frozen_inference_graph.pb')\nPATH_TO_LABELS = os.path.join(CWD_PATH, 'object_detection', 'data', 'mscoco_label_map.pbtxt')\n\nNUM_CLASSES = 2\nlabel_map = label_map_util.load_labelmap(PATH_TO_LABELS)\n\ncategories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES,\n                                                            use_display_name=True)\n\ncategory_index = label_map_util.create_category_index(categories)\n\ndef detect_objects(image_np, sess, detection_graph):\n    # 增加输入图像的维度: [1, None, None, 3]\n    image_np_expanded = np.expand_dims(image_np, axis=0)\n    image_tensor = detection_graph.get_tensor_by_name('image_tensor:0')\n    # 得到检测框\n    boxes = detection_graph.get_tensor_by_name('detection_boxes:0')\n    #得到他的得分\n    scores = detection_graph.get_tensor_by_name('detection_scores:0')\n    classes = detection_graph.get_tensor_by_name('detection_classes:0')\n    num_detections = detection_graph.get_tensor_by_name('num_detections:0')\n    # Actual detection.\n    # 这里的class是包含多个识别种类的二维数组\n    #[[100,4]]boxes 每个框的位置坐标,    scores 100个 ,     classes 100个 ,    num_detections 100个\n    (boxes, scores, classes, num_detections) = sess.run(\n        [boxes, scores, classes, num_detections],\n        feed_dict={image_tensor: image_np_expanded})\n    # Visualization of the results of a detection.\n    vis_util.visualize_boxes_and_labels_on_image_array(\n        image_np,\n        np.squeeze(boxes),\n        np.squeeze(classes).astype(np.int32),\n        np.squeeze(scores),\n        category_index,\n        use_normalized_coordinates=True,\n        line_thickness=4,\n        min_score_thresh=0.5)\n    return image_np\n\nif __name__ == '__main__':\n    detection_graph = tf.Graph()\n    with detection_graph.as_default():\n        od_graph_def = tf.GraphDef()\n        with tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid:\n            serialized_graph = fid.read()\n            od_graph_def.ParseFromString(serialized_graph)\n            tf.import_graph_def(od_graph_def, name='')\n    sess = tf.Session(graph=detection_graph)\n    video_capture = cv2.VideoCapture('b.mp4')\n    fps = FPS().start()\n    frame_width = int(video_capture.get(3))\n    frame_height = int(video_capture.get(4))\n    # define video output\n    out = cv2.VideoWriter('outpy.mp4', cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'), 10, (frame_width, frame_height))\n    count = 0\n    while video_capture.isOpened():\n        ret, frame = video_capture.read()\n        t = time.time()\n        detected_image = detect_objects(frame, sess, detection_graph)\n        fps.update()\n        cv2.imshow('Video', detected_image)\n\t\t#本来想来做个更加流畅的优化、就是格一个帧进行识别、但还是会阻塞\n        #if count % 100 == 0:\n        #    print(count)\n        # write to video file\n        #out.write(detected_image)\n        # print('[INFO] elapsed time: {:.2f}'.format(time.time() - t))\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            break\n\n    fps.stop()\n    video_capture.release()\n    sess.close()\n    cv2.destroyAllWindows()\n\n```\n```python\n#visualization_untils\n#第160行进行如下修改、check为inception3的入口、将图片和坐标传入\n  if use_normalized_coordinates:\n    (left, right, top, bottom) = (xmin * im_width, xmax * im_width,\n                                  ymin * im_height, ymax * im_height)\n    \n    name=check(image.copy(), left, right, top, bottom)\n\t\n\t\n##188 行处\t\n#name为全局变量、接受inception3识别结果的字符串\ndraw.text(\n        (left + margin, text_bottom - text_height - margin),\n        name,\n        fill='black',\n        font=font)\n\n```\n\n```python\n\n#check模块、inception3的入口\nimport tensorflow as tf\nimport numpy as np\nfrom pylab import array\n\ndef check(image,left, right, top, bottom):\n    got = array(image)\n    crop_img = got[int(top):int(bottom), int(left):int(right), 0:3]\n\t#载入之前自己训练的模型\n    with tf.gfile.FastGFile('output_graph.pb', 'rb') as f:\n        graph_def = tf.GraphDef()\n        graph_def.ParseFromString(f.read())\n        tf.import_graph_def(graph_def, name='')\n\n    with tf.Session() as sess:\n        softmax_tensor = sess.graph.get_tensor_by_name('final_result:0')\n\t\t#将传入的图片格式转化一下\n        first = tf.image.convert_image_dtype(crop_img, dtype=tf.float32)\n        # jpeg 进行编码\n        # eval()想当于将tensorflow的存储格式中提取出来以数组的格式\n        encode = tf.image.encode_jpeg(first.eval())\n        #将编码好的图片传入以decodejpeg的格式\n        predictions = sess.run(softmax_tensor, {'DecodeJpeg/contents:0': encode.eval()})  # 图片格式是jpeg格式\n        predictions = np.squeeze(predictions)  # 把结果转为1维数据\n        top_k = predictions.argsort()[::-1]\n        if top_k[0]==1:\n            human_string=\"unsafe\"\n        else:\n            human_string=\"safe\"\n        return human_string\n        #返回给画框的代码\n```\n\n## 总结\n看似十分完美流程的过程在实际运行时由于笔记本配置低下(好想要GPU的台式机！！)、换了一台配置稍微高一点的本、但还是崩了、tensorflow开两个session的内存消耗比想象中的要大、开\n看来这操作只能是活在梦里了、希望以后能想出一种底层之间的优化(相比之前的已经做了很多IO的优化、但主要问题还是这是线性的操作、一定有卡顿来进行二次判断)\n\n## 更新！！！\n终于找到了问题所在！！原来每一帧的图像传入后都要重新加载一次graph！！所以导致内存直接爆炸！改动后可以跑的动了、但比较吃配置配置高一点的话可以更加流畅吧、\n具体改动如下、其余的改动就是要在每个调用的visualization_utils中的函数里传入初始化的graph、具体修改如下、整个项目会放到github上\n\n```python\n#主要是对main函数下的修改vediondetection.py\n\nif __name__ == '__main__':\n    #tf.Graph()生成新的图\n    detection_graph = tf.Graph()\n    inceptionsess =tf.Graph()\n    with inceptionsess.as_default():\n        od_graph_def = tf.GraphDef()\n        with tf.gfile.FastGFile('output_graph.pb', 'rb') as f:\n            serialized_graph = f.read()\n            od_graph_def.ParseFromString(serialized_graph)\n            tf.import_graph_def(od_graph_def, name='')\n\n    with detection_graph.as_default():\n        od_graph_def = tf.GraphDef()\n        with tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid:\n            serialized_graph = fid.read()\n            od_graph_def.ParseFromString(serialized_graph)\n            tf.import_graph_def(od_graph_def, name='')\n    sess = tf.Session(graph=detection_graph)\n    video_capture = cv2.VideoCapture('b.mp4')\n    fps = FPS().start()\n    frame_width = int(video_capture.get(3))\n    frame_height = int(video_capture.get(4))\n    # define video output\n    out = cv2.VideoWriter('outpy.mp4', cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'), 10, (frame_width, frame_height))\n    count = 0\n    while video_capture.isOpened():\n        ret, frame = video_capture.read()\n        t = time.time()\n        detected_image = detect_objects(frame, sess, detection_graph,inceptionsess)\n        fps.update()\n        out.write(detected_image)\n        cv2.imshow('Video', detected_image)\n        if cv2.waitKey(1) & 0xFF == ord('q'):\n            break\n    fps.stop()\n    video_capture.release()\n    sess.close()\n    cv2.destroyAllWindows()\n```\n\n\n```python\n#对checker类的方法进行的改动\n\ndef check(image,left, right, top, bottom,inceptionsess):\n    got = array(image)\n    crop_img = got[int(top):int(bottom), int(left):int(right), 0:3]\n    # with tf.gfile.FastGFile('output_graph.pb', 'rb') as f:\n    #     graph_def = tf.GraphDef()\n    #     graph_def.ParseFromString(f.read())\n    #     tf.import_graph_def(graph_def, name='')\n    with tf.Session(graph=inceptionsess) as sess:\n        softmax_tensor = sess.graph.get_tensor_by_name('final_result:0')\n        # jpeg 进行编码\n        # \"\"\"Return the value of the tensor represented by this handle.\"\"\n        encode = tf.image.encode_jpeg(crop_img)\n        predictions = sess.run(softmax_tensor, {'DecodeJpeg/contents:0': encode.eval()})  # 图片格式是jpg格式\n        predictions = np.squeeze(predictions)  # 把结果转为1维数据\n        top_k = predictions.argsort()[::-1]\n        if top_k[0]==1:\n            human_string=\"unsafe\"\n        else:\n            human_string=\"safe\"\n        return human_string\n\n```\n\n","tags":["图像识别"],"categories":["机器学习"]},{"title":"定点识别","url":"/2018/04/08/2018-4-8/","content":"<Excerpt in index | 首页摘要>\n基于object_detection训练自己的模型\n<!-- more -->\n花了不知道多少天、、主要参加一个定点识别的比赛、算是把模型搞定了、虽然结果十分的令人喜感（哈哈、不说了）、、难度有一点大（主要是各种天坑、在这里记录一下）\n\n这是阿里天池的比赛、比赛给出上万张图片主要是服装、要在每个图片上识别出服装每个关键点、并将识别结果的坐标输出、比如左袖口什么的、差不多有24个标签吧、训练集给出的是每个图片的所有关键点的坐标、我的思路是先根据坐标\n转化成矩形框(同时对x和y加上自己定义的距离数)、然后通过object_detection确定定位的位置、最后在进行输出(求两个x和两个y的平均来得到中心点)、具体步骤如下：\n\n## 根据lable切分图片\n\n这个脚本主要是根据lable对图片进行切分、根据lable创建若干个文件夹、切好的图片放到每个对应的文件加下、切分完得到几十万张图片(此刻的内心是奔溃的)、\n```python\nimport csv\nimport cv2\nimport os\n\npath=os.getcwd()\n#自己定义框的宽度wide\ndef drawcnts_and_cut(original_img,x,y,wide):\n    x1=x-wide\n    x2=x+wide\n    y1=y-wide\n    y2=y+wide\n    crop_img = original_img[y1:y2, x1:x2]\n    return  crop_img\n\ndef start(img_path,save_path,x,y):\n    original_img= cv2.imread(img_path)\n    crop_img = drawcnts_and_cut(original_img,int(x),int(y),25)\n    cv2.imwrite(save_path, crop_img)\ndef datatranslate(data):\n    splited=str(data).split()\n    return splited[0],splited[1]\n\t\n#自己根据标签数量来改\nlable=['class1', 'class2']\t\ncsv_reader = csv.reader(open('train\\\\input.csv', encoding='utf-8'))\nnum=0\nfor row in csv_reader:\n    for i in range(2,26,1):\n        photo=row[0]\n        data=row[i]\n        category=lable[i]\n        splited = str(row[i]).split(\"_\")\n        print(photo)\n        print(num)\n        if int(splited[0])!=-1:\n            lib = path + \"\\\\train\\\\\"+photo\n            savepath=path+\"\\\\output\\\\\"+str(category)+\"\\\\\"+str(category)+\"+\"+str(num)+\".jpg\"\n            num+=1\n            start(lib,savepath,splited[0],splited[1])\n\t\t\t\n```\n\n\n## 将图片转化为对应的xml文件\n\n默认的边框大小为整个图片的d、长度和宽度可以从图片中获取、最终批量的生成xml文件（突然想起比赛的图片切分后生成的30万个文件、还只能分批次的复制、一复制就卡屏、迷醉、、）\n```python\nimport os, sys\nimport glob\nfrom PIL import Image\n\n#根据实际来添加class\nlist=[\"class1\",\"class2\"]\nfor a in list:\n    path=os.getcwd()\n    #图像存储位置\n    src_img_dir = path+\"\\\\input2\\\\\"+a\n    # xml文件存放位置\n    src_xml_dir = path+\"\\\\input2\\\\\"+a\n    img_Lists = glob.glob(src_img_dir + '\\*.jpg')\n    img_basenames = [] \n    for item in img_Lists:\n        img_basenames.append(os.path.basename(item))\n    img_names = [] \n    for item in img_basenames:\n        temp1, temp2 = os.path.splitext(item)\n        img_names.append(temp1)\n    for img in img_names:\n        im = Image.open((src_img_dir + '/' + img + '.jpg'))\n        width, height = im.size\n        xml_file = open((src_xml_dir + '/' + img + '.xml'), 'w')\n        xml_file.write('<annotation>\\n')\n        xml_file.write('    <folder>'+a+'</folder>\\n')\n        xml_file.write('    <filename>' + str(img) + '.jpg' + '</filename>\\n')\n        xml_file.write('    <path>' + path +\"\\\\input2\\\\\"+a+\"\\\\\"+ str(img) + '.jpg'+ '</path>\\n')\n        xml_file.write('    <size>\\n')\n        xml_file.write('        <width>' + str(width) + '</width>\\n')\n        xml_file.write('        <height>' + str(height) + '</height>\\n')\n        xml_file.write('        <depth>3</depth>\\n')\n        xml_file.write('    </size>\\n')\n        xml_file.write('        <segmented>0</segmented>\\n')\n        xml_file.write('    <object>\\n')\n        xml_file.write('        <name>' + str(img) + '</name>\\n')\n        xml_file.write('        <pose>Unspecified</pose>\\n')\n        xml_file.write('        <truncated>1</truncated>\\n')\n        xml_file.write('        <difficult>0</difficult>\\n')\n        xml_file.write('        <bndbox>\\n')\n        xml_file.write('            <xmin>' + \"0\" + '</xmin>\\n')\n        xml_file.write('            <ymin>' + \"0\" + '</ymin>\\n')\n        xml_file.write('            <xmax>' + str(width) + '</xmax>\\n')\n        xml_file.write('            <ymax>' + str(height) + '</ymax>\\n')\n        xml_file.write('        </bndbox>\\n')\n        xml_file.write('    </object>\\n')\n        xml_file.write('</annotation>')\n\t\t\n```\n##\txml转csv文件合并csv文件\n\n要使用如下脚本将xml文件转化为csv文件、最后再把每个目录下的csv文件进行合并（注意删除重复的lable）\n\n```python\n#xml转csv文件合并csv文件\n\nimport os\nimport glob\nimport pandas as pd\nimport xml.etree.ElementTree as ET\ntag=['class1','class2']\nnum=0\n\ndef xml_to_csv(path):\n    xml_list = []\n    for xml_file in glob.glob(path + '/*.xml'):\n        tree = ET.parse(xml_file)\n        root = tree.getroot()\n        for member in root.findall('object'):\n            value = (root.find('filename').text,\n                     int(root.find('size')[0].text),\n                     int(root.find('size')[1].text),\n                     root.find('folder').text,\n                     int(member[4][0].text),\n                     int(member[4][1].text),\n                     int(member[4][2].text),\n                     int(member[4][3].text)\n                     )\n            xml_list.append(value)\n    column_name = ['filename', 'width', 'height', 'class', 'xmin', 'ymin', 'xmax', 'ymax']\n    xml_df = pd.DataFrame(xml_list, columns=column_name)\n    return xml_df\n\n\ndef main():\n    for a in tag:\n        image_path = os.path.join(os.getcwd(), 'input2\\\\'+a)\n        xml_df = xml_to_csv(image_path)\n        xml_df.to_csv('data\\\\'+str(a)+'.csv',index=None)\n        print('Successfully converted xml to csv.')\n\n\nmain()\n```\n通过shell批量合并csv\n```shell\n@echo off\nE:\ncd add\ndir\ncopy *.csv all_keywords.csv\necho 合并成功！'\npause\n```\n\n## 调用object_detection前的准备\n\n下面是很有参考性的博客和官方的地址\n[https://blog.csdn.net/honk2012/article/details/79099651](https://blog.csdn.net/honk2012/article/details/79099651)\n[https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/installation.md](https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/installation.md)\n可以翻墙的话推荐下面这篇、这个towardsdatascience还是很不错的\n[https://towardsdatascience.com/how-to-train-your-own-object-detector-with-tensorflows-object-detector-api-bec72ecfe1d9](https://towardsdatascience.com/how-to-train-your-own-object-detector-with-tensorflows-object-detector-api-bec72ecfe1d9)\n基本后面的训练和模型的调用都是在github上的、想普通的个人电脑用ssd的一个mobile就行了、别的根本跑不动、batch设置的越大每次迭代的时间越长、如果太大电脑配置不够的话你就可以重新开机了、、\n顺便说说几个坑官方步骤中的 protoc object_detection/protos/*.proto --python_out=. 如果是在window下要下载3.4版本的3.5会有bug\nobject_detection初始化一定要先执行、不然会给你各种报错、、\n官方文档中export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim  如果是windows下执行要用这个命令(查了很久用了很多的坑爹方法、只能说项目对windows不友好)SET PYTHONPATH=%cd%;%cd%\\slim  执行目录还是不变\n注意这几个坑基本就会很顺畅了、还有一些其他小坑一时想不起来、想到了再加、\n\n\n\n\n\n","tags":["图像识别"],"categories":["机器学习"]},{"title":"博客搬家","url":"/2018/03/23/2018-3-23/","content":"<Excerpt in index | 首页摘要>\n无意间看到了Hexo的这个黑蓝主题、实在是太cool了！！抽空用了两个晚上搬家\n<!-- more -->\n原来的博客一直是用的是jekyll(差点又拼错、)、还是很方便不过还是有很多弊端\n\n1、代码高亮、现在看看原来的博客这代码高亮、、简直无法直视、虽然后来另外装了插件但还是惨不忍睹(主要是这个主题的高亮真的是太漂亮了、看了会上瘾、、)\n2、由于原来的博客用的是老外的主题为了实现想要的效果文字间的空格符有点受不了、十分影响美观、还有字体(这里支持一下国产、、)\n3、这个主题有分类功能、随着博客的增多查找也比原来的方便、\n4、也是主要原因、、就是想换、笑死、、、\n\n现在终于换好了、过程也十分折腾、也遇到了各种坑、什么Hexo的版本问题、server要独立安装、、、希望这博客可以用几年吧、、同时再次感谢maochunguang提供的主题\n\n前端真的是一个十分神奇的东西、、但真的没工夫投在上面学了、还有评论功能、看了大佬的主题demo觉得加了评论就不是十分洁简了、于是就不做了（绝不是因为懒）、、\n\n最后注意我的背景:它是会变的哦、、、\n","tags":["other"],"categories":["other"]},{"title":"K-近邻算法Python实现","url":"/2018/01/30/2018-1-30/","content":"<Excerpt in index | 首页摘要>\n运用python通过计算距离来实现对某花的分类\n<!-- more -->\n## 算法解决的问题\n已知样本集（此处的样本为某花的实例数据）、给定一未知样本的数据来断此样本的类别(此处为判断属于哪一类花）\n## 解决步骤\n特征抽取后计算出未知样本到所有已知样本的距离、根据给定参数K（最好为奇数便于投票）选出K个最近的样本点、统计出类别最多的样本点的类别、最终的的分类就是该类别\n缺陷：数据的分布不均匀会导致结果的不准确\n优化方法：根据距离的远近添加相应的权重来弱化数据分布不均匀的为题（下面代码还没实现权重的添加、、以后有空再加、、、）\n个人脑洞：对于多维的数据、在二维分布上可能看不出任何规律、但在高维的空间中明显的可以分开好几个类别（如本例的某花数据在三维下就很明显了、还有支持向量机的划分方法太cool了）\n此处的样本集（非常nice的数据集大全）\n[http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data](http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data)\n样本集示例：前四列为花的数据、最后为花的类别\n\n5.1,3.5,1.4,0.2,Iris-setosa\n\n5.0,3.3,1.4,0.2,Iris-setosa\n\n7.0,3.2,4.7,1.4,Iris-versicolor\n\n4.6,3.1,1.5,0.2,Iris-setosa\n\n6.4,3.2,5.3,2.3,Iris-virginica\n\n6.9,3.2,5.7,2.3,Iris-virginica\n\n4.6,3.4,1.4,0.3,Iris-setosa\n\n代码实现如下：用测试集测试可以达到96%的准确率\n\n```python\n\nimport csv\nimport math\nfrom collections import Counter\n\n#导入样本集list\n#导入测试集计算测试集到每个样本集的距离,结果保存为list\n#根据distance排名取k个投票选出最多的这个类\n\n\n#传递时要第二个参数要为空参否则会共用同一个地址\ndef readfile(local):\n    dataset=[]\n    with open(local) as file2:\n        csv_reader = csv.reader(file2)\n        for line in csv_reader:\n            dataset.append(line)\n    return dataset\n\n\ndef distance (test,train):\n    result=0.0\n    #此时每个test例如[1,2,3,4]每个train例如[1,2,3,4,a],-1除去标签\n    for i in  range(len(test)-1):\n        result=result+math.sqrt(abs((float(test[i])-float(train[i]))*(float(test[i])+float(train[i]))))\n    return result\n\ndef sort(train,test,k=3):\n    result=[]\n    sortresult=[]\n    #计算每个样本集到样本的距离\n    for i in range(len(test)):\n        for m in range(len(train)):\n            #对于每个测试实例得到距离和对应的标签\n            result.append([distance(test[i],train[m]),train[m][-1]])\n        sortresult.append(findsort(result,k))#得到每一个测试集的分类结果\n        result=[]                            #将每个测试集的距离集合清空\n    return sortresult       #最终结果\n    #得到结果集，每一个test到样本集的距离\n\n#示例输入[[3.917258917468777, 'Iris-setosa'], [4.365595716195167, 'Iris-setosa']]\ndef findsort(data,k=3):\n    result={}\n    voat=[]\n    for x in range(len(data)):\n            result.update({data[x][0]:data[x][1]})\n    #对字典进行排序从小到大\n    a=sorted(result.items(), key=lambda d: d[0])\n    for m in range(k):\n         voat.append(a[m][-1])\n    #得到列表中出现次数最多的元素\n    b=Counter(voat).most_common(1)\n    return b[0][0]\n\n#计算准确率\ndef correct(sample,predict):\n    flag=0\n    for a in range(len(sample)):\n        if(sample[a]==predict[a]):\n            flag=flag+1\n    return flag/len(sample)\n\ndef main():\n    testlist=[]\n    train=list(readfile(\"F:\\\\train.csv\"))\n    test=list(readfile(\"F:\\\\test.csv\"))\n    #k为最近邻的个数\n    output=sort(train,test,3)\n    #得到分类的结果集\n    print(output)\n    for a in range(len(test)):\n        testlist.append(test[a][-1])\n    #输出准确率\n    print(correct(testlist,output))\nmain()\n\n```\n\n\n\n\n\n\n\n\n\n\n","tags":["python"],"categories":["机器学习"]},{"title":"基本神经网络","url":"/2017/12/10/2017-12-10/","content":"<Excerpt in index | 首页摘要>\n简单整理一下神经网络训练的步骤\n<!-- more -->\n总结一下最简单的神经网络的训练过程和原理\n通常利用数据交叉验证来提高数据利用率\n<img src=\"http://aRootUser.github.io/img/2/1.jpg\">\n交叉验证：给定一个训练集和测试集，为了最大程度的利用测试集，可以将训练集分为若干份，这里为5。第一次将fold1(折)作为测试集其余的作为训练集，第二次将fold2作为测试集，其余的作为训练集，以此类推从而达到最大化利用数据更新权重的效果\n<img src=\"http://aRootUser.github.io/img/2/2.jpg\">\n对于输入的一张图片简单将图片的输入像素点看成[1,4]的矩阵、输出层为[1,3],中间的权值为[4,3]的矩阵、和图中不同图中是左成矩阵、这里定义的是右乘矩阵、没有定义中间层、最后还要加上[1,3]偏置值得到[1,3]的输出值每一个值代表某一类别的得分、\n<img src=\"http://aRootUser.github.io/img/2/3.jpg\">\n为了更好的定以中间权值定义的好坏以及预测结果的准确程度、用损失函数来衡量、损失函数最小表示预测越准确、这里定义的是svm损失函数、\nl 表示自己定义的可容忍的长度\nyi表示正确类别的得分\nj表示其他类别的得分\n通过计算每个其他类别减去正确类别的得分的最大值的求和来表是损失函数的结果对于多个输入例如输入100张图片还要除去100相当于取平均值\n<img src=\"http://aRootUser.github.io/img/2/4.jpg\">\n为了防止权值为0从而导致输入样本的每一个值没有被充分利用例如训练得到的两个权值\n设输入的样本为[1,1,1,1]\n权重W1[0.5,0.5,0.5,0.5]    \n权重W2[1,0,0,0]\n矩阵相乘后得到的结果相同但是w2由于有三个0没有充分利用每一项所以添加w的平方项来惩罚权重为w2的情况、使其损失值变大\t\n<img src=\"http://aRootUser.github.io/img/2/5.jpg\">\n<img src=\"http://aRootUser.github.io/img/2/6.jpg\">\n分类器的作用将输出的值通过sigmoid函数映射到0至1的区间上、e的x次幂进行放大、最后通过取其作为正确类别的概率取负对数得最终其对应的损失值(因为概率越大越输出的损失值越小)\n前向传播：从输入的x一直到计算出loss、通过梯度下降算法找到一个下降方向、最终找到最低点、训练的批次数一般为2的整数次幂\n一个Epoch表示迭代完所有数据、一个迭代表示跑完当前的一个batch\n## 学习率\n每次训练跟新权重的变化要乘一个学习率来调整权值变化的大小、过大会错过最优解\n## 反向传播\n通过计算出每一个权重对最终的loss值的影响来调整权重的大小(向前传播的逆向求解)\n## 激活函数 \n对神经元的输出进行去线性化、例如sigmoid函数(由于当x过大时很容易导致梯度消失使其无法求导进行反向传播、现在一般用relu激活函数并且求导简单）\n## 过拟合问题 \ndrop-out进行处理通过迭代来弥补神经网络的复杂度\n## 过程小结 \n首先输入训练集如手写数字集、定义神经网络后、通过向前传播得到对每一个类别的输出、通过sortmax函数将输出转化为概率分布、通过与标签进行如下运算个（标签是one-hot概率）、将输出的概率分布取对数与标签值乘积在做平均值求和最后取负数-tf.reduce_sum(y_*tf.log(y))、得到交叉熵来反应结果集与标签的相似度、最后通过梯度下降法不断训练使交叉熵最小、来优化权重参数、\n\n\n\n\n\n\n\n\n\n\n","tags":["机器学习"],"categories":["机器学习"]}]