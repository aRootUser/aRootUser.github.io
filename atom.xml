<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>welcome to my blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.shadowerli.com/"/>
  <updated>2018-09-15T10:57:40.000Z</updated>
  <id>https://www.shadowerli.com/</id>
  
  <author>
    <name>Shadowerli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hdfs RPC流程</title>
    <link href="https://www.shadowerli.com/2018/09/13/2018-9-13/"/>
    <id>https://www.shadowerli.com/2018/09/13/2018-9-13/</id>
    <published>2018-09-12T16:00:00.000Z</published>
    <updated>2018-09-15T10:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>先从最基本的RPC调用的源码开始着手<br><a id="more"></a><br>简单总结hdfs RPC执行的全部流程</excerpt></p><h2 id="RPC调用入口"><a href="#RPC调用入口" class="headerlink" title="RPC调用入口"></a>RPC调用入口</h2><p>首先为了获得代理对象会执行RPC.getProxy()中的Proxy.newInstace()获得实例<br>初始化这个实例时会初始化参数InvocationHandler这个类<br>调用具体代理方法时会调用InvocationHandler里面已经重写过的invoke()方法<br>这个方法里定义了与远程的链接通过这个方法便能获得远程调用后方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//启动客户端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ClientNamenodeProtocol namenode = RPC.getProxy(ClientNamenodeProtocol.class, <span class="number">1L</span>,</span><br><span class="line"><span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9999</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">String metaData = namenode.getMetaData(<span class="string">"/a.a"</span>);</span><br><span class="line">System.out.println(metaData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//工厂方法、、、、</span></span><br><span class="line">Builder builder = <span class="keyword">new</span> RPC.Builder(<span class="keyword">new</span> Configuration());</span><br><span class="line">builder.setBindAddress(<span class="string">"localhost"</span>)</span><br><span class="line">.setPort(<span class="number">9999</span>)</span><br><span class="line">.setProtocol(ClientNamenodeProtocol.class)</span><br><span class="line">.setInstance(<span class="keyword">new</span> MyNameNode());</span><br><span class="line">Server server = builder.build();</span><br><span class="line">server.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RPC.getProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; protocol, <span class="keyword">long</span> clientVersion,netSocketAddress addr, Configuration conf)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getProtocolProxy(protocol, clientVersion, addr, conf).getProxy();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//如果配置文件里没有配置返回一个默认的socketFactory</span></span><br><span class="line"><span class="function">SocketFactory <span class="title">getDefaultSocketFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">//经过一系列调用得到RPC的引擎</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> RpcEngine <span class="title">getProtocolEngine</span><span class="params">(Class&lt;?&gt; protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">      Configuration conf)</span> </span>&#123;</span><br><span class="line">    RpcEngine engine = PROTOCOL_ENGINES.get(protocol);</span><br><span class="line">    <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">      Class&lt;?&gt; impl = conf.getClass(ENGINE_PROP+<span class="string">"."</span>+protocol.getName(),</span><br><span class="line">                                    WritableRpcEngine.class);</span><br><span class="line">      <span class="comment">//用反射工具类实例化一个对象imp是这个引擎的全限定名，conf是配置文件 6个xml文件</span></span><br><span class="line">      engine = (RpcEngine)ReflectionUtils.newInstance(impl, conf);</span><br><span class="line">      <span class="comment">//此处protocol为一开始传入的接口的全限定名</span></span><br><span class="line">      PROTOCOL_ENGINES.put(protocol, engine);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> engine;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//拿到引擎后开始调用引擎的getProxy方法</span></span><br><span class="line"><span class="comment">//在writable引擎中</span></span><br><span class="line"><span class="comment">//tag1----</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ProtocolProxy&lt;T&gt; <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//开始动态代理</span></span><br><span class="line">    T proxy = (T)</span><br><span class="line">    <span class="comment">//拿到协议的类加载器</span></span><br><span class="line">    Proxy.newProxyInstance(protocol.getClassLoader(),<span class="keyword">new</span> Class[] &#123; protocol &#125;, <span class="keyword">new</span> Invoker(protocol, addr, ticket, conf,factory, rpcTimeout, fallbackToSimpleAuth));</span><br><span class="line">    <span class="comment">//上方起跳</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProtocolProxy&lt;T&gt;(protocol, proxy,  <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到引擎后开始调用引擎的getProxy方法</span></span><br><span class="line"><span class="comment">//在writable引擎中</span></span><br><span class="line"><span class="comment">//getProxy方法中的动态代理拿到中的参数要实例化Invoker</span></span><br><span class="line"><span class="comment">//在构造方法中主要初始化Invoker成员变量</span></span><br><span class="line"><span class="comment">//重要的有Client</span></span><br><span class="line"><span class="comment">//这个内部类实现了RpcInvocationHandler这个接口</span></span><br><span class="line"><span class="comment">//ConnectionId是Client的静态内部类事先已经导入</span></span><br><span class="line"><span class="comment">//这个类保存地址和用户ticket。客户端连接</span></span><br><span class="line"><span class="comment">//服务器的唯一标识是&lt;remoteAddress, protocol, ticket&gt; ticket的一个例子“123,auth:SIMPLE”</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Class&lt;?&gt; protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">                   InetSocketAddress address, UserGroupInformation ticket,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Configuration conf, SocketFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> rpcTimeout, AtomicBoolean fallbackToSimpleAuth)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.remoteId = ConnectionId.getConnectionId(address, protocol,</span><br><span class="line">          ticket, rpcTimeout, conf);</span><br><span class="line">      <span class="keyword">this</span>.client = CLIENTS.getClient(conf, factory);</span><br><span class="line">      <span class="keyword">this</span>.fallbackToSimpleAuth = fallbackToSimpleAuth;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//拿到引擎后开始调用引擎的getProxy方法</span></span><br><span class="line"><span class="comment">//在writable引擎中</span></span><br><span class="line"><span class="comment">//getProxy方法中的动态代理拿到中的参数要实例化Invoker</span></span><br><span class="line"><span class="comment">//在构造方法中主要初始化Invoker成员变量</span></span><br><span class="line"><span class="comment">//初始化成员变量时要通过getClient来获得client</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//getClient会从这里面的map中拿到getClient()方法key是socket Factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;SocketFactory, Client&gt; clients = <span class="keyword">new</span> HashMap&lt;SocketFactory, Client&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第一次的入口</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Client <span class="title">getClient</span><span class="params">(Configuration conf, SocketFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getClient(conf, factory, ObjectWritable.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Client <span class="title">getClient</span><span class="params">(Configuration conf,</span></span></span><br><span class="line"><span class="function"><span class="params">      SocketFactory factory, Class&lt;? extends Writable&gt; valueClass)</span> </span>&#123;</span><br><span class="line">    Client client = clients.get(factory);</span><br><span class="line">    <span class="comment">//没有的话造一个Client第一次的话是没有的</span></span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">      client = <span class="keyword">new</span> Client(valueClass, conf, factory);</span><br><span class="line">      clients.put(factory, client);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      client.incCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Client.LOG.isDebugEnabled()) &#123;</span><br><span class="line">      Client.LOG.debug(<span class="string">"getting client out of cache: "</span> + client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到引擎后开始调用引擎的getProxy方法</span></span><br><span class="line"><span class="comment">//在writable引擎中</span></span><br><span class="line"><span class="comment">//getProxy方法中的动态代理拿到中的参数要实例化Invoker</span></span><br><span class="line"><span class="comment">//在构造方法中主要初始化Invoker成员变量</span></span><br><span class="line"><span class="comment">//初始化成员变量时要通过getClient来获得client</span></span><br><span class="line"><span class="comment">//拿到Client后继续初始化成员变量</span></span><br><span class="line"><span class="comment">//现在在writable的引擎内部Invoker类中</span></span><br><span class="line"><span class="comment">//初始化完成后回到这里</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//tag1----对应上方</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ProtocolProxy&lt;T&gt; <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//开始动态代理</span></span><br><span class="line">    T proxy = (T)</span><br><span class="line">    <span class="comment">//拿到协议的类加载器</span></span><br><span class="line">    Proxy.newProxyInstance(protocol.getClassLoader(),<span class="keyword">new</span> Class[] &#123; protocol &#125;, <span class="keyword">new</span> Invoker(protocol, addr, ticket, conf,factory, rpcTimeout, fallbackToSimpleAuth));</span><br><span class="line">    <span class="comment">//上方起跳</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProtocolProxy&lt;T&gt;(protocol, proxy,  <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个另外独立的类</span></span><br><span class="line"><span class="comment">//类包围了服务器的代理，</span></span><br><span class="line"><span class="comment">//包含其支持的方法列表。</span></span><br><span class="line"><span class="comment">//一个值为null的方法列表来表示客户端和服务器有相同的协议。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//接口的全限定名</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; protocol;</span><br><span class="line">    <span class="keyword">private</span> T proxy;</span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Integer&gt; serverMethods = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造方法初始化变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolProxy</span><span class="params">(Class&lt;T&gt; protocol, T proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> supportServerMethodCheck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    <span class="comment">//这里会对其报错但不影响RuntimeException</span></span><br><span class="line">    <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">    <span class="keyword">this</span>.supportServerMethodCheck = supportServerMethodCheck;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new 完ProtocolProxy并返回对象然后回到一开始的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; protocol, <span class="keyword">long</span> clientVersion,netSocketAddress addr, Configuration conf)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getProtocolProxy(protocol, clientVersion, addr, conf).getProxy(.......);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//现在回到程序的入口开始执行这条语句</span></span><br><span class="line">String metaData = namenode.getMetaData(<span class="string">"/a.a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getMetaData方法时会调用writable的invoker内部类中的invoke方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        startTime = Time.now();</span><br><span class="line">      &#125;</span><br><span class="line">      TraceScope traceScope = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//这个方法存疑。。。</span></span><br><span class="line">      <span class="keyword">if</span> (Trace.isTracing()) &#123;</span><br><span class="line">        traceScope = Trace.startSpan(</span><br><span class="line">            method.getDeclaringClass().getCanonicalName() +</span><br><span class="line">            <span class="string">"."</span> + method.getName());</span><br><span class="line">        <span class="comment">//getName直接跳到下面</span></span><br><span class="line">        <span class="comment">//得到非常完整的公有、全限定名、方法名、参数</span></span><br><span class="line"><span class="comment">//tag2--------------------</span></span><br><span class="line">      &#125;</span><br><span class="line">      ObjectWritable value;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//tag3--------------------</span></span><br><span class="line">        value = (ObjectWritable)</span><br><span class="line">          client.call(RPC.RpcKind.RPC_WRITABLE, <span class="keyword">new</span> Invocation(method, args),</span><br><span class="line">            remoteId, fallbackToSimpleAuth);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (traceScope != <span class="keyword">null</span>) traceScope.close();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">long</span> callTime = Time.now() - startTime;</span><br><span class="line">        LOG.debug(<span class="string">"Call: "</span> + method.getName() + <span class="string">" "</span> + callTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//又进入了引擎的静态内部类</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Invocation</span> <span class="keyword">implements</span> <span class="title">Writable</span>, <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterClasses;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Configuration conf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> clientVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> clientMethodsHash;</span><br><span class="line">    <span class="keyword">private</span> String declaringClassProtocolName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invocation</span><span class="params">(Method method, Object[] parameters)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.methodName = method.getName();</span><br><span class="line">      <span class="keyword">this</span>.parameterClasses = method.getParameterTypes();</span><br><span class="line">      <span class="keyword">this</span>.parameters = parameters;</span><br><span class="line">      rpcVersion = writableRpcVersion;</span><br><span class="line">      <span class="keyword">if</span> (method.getDeclaringClass().equals(VersionedProtocol.class)) &#123;</span><br><span class="line">        <span class="comment">//VersionedProtocol is exempted from version check.</span></span><br><span class="line">        clientVersion = <span class="number">0</span>;</span><br><span class="line">        clientMethodsHash = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.clientVersion = RPC.getProtocolVersion(method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">this</span>.clientMethodsHash = ProtocolSignature.getFingerprint(method</span><br><span class="line">            .getDeclaringClass().getMethods());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果协议类具有ProtocolAnnotation，则获取协议注释中的名称;否则，类名就是协议名。暂时不明白作用</span></span><br><span class="line">      <span class="comment">//同之前赋予了非常详细的方法名。。。</span></span><br><span class="line">      <span class="keyword">this</span>.declaringClassProtocolName = </span><br><span class="line">          RPC.getProtocolName(method.getDeclaringClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新回到tag2----开始tag3----</span></span><br><span class="line"><span class="comment">//client中的call</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Writable <span class="title">call</span><span class="params">(RpcKind rpcKind, Writable rpcRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">      ConnectionId remoteId, AtomicBoolean fallbackToSimpleAuth)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> call(rpcKind, rpcRequest, remoteId, RPC.RPC_SERVICE_CLASS_DEFAULT,</span><br><span class="line">      fallbackToSimpleAuth);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续在类里面重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Writable <span class="title">call</span><span class="params">(RpcKind rpcKind, Writable rpcRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">      ConnectionId remoteId, <span class="keyword">int</span> serviceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      AtomicBoolean fallbackToSimpleAuth)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//tag4---------------------开始跳</span></span><br><span class="line">    <span class="keyword">final</span> Call call = createCall(rpcKind, rpcRequest);</span><br><span class="line"><span class="comment">//tag5--------------开始跳</span></span><br><span class="line">    Connection connection = getConnection(remoteId, call, serviceClass,</span><br><span class="line">      fallbackToSimpleAuth);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      connection.sendRpcRequest(call);                 <span class="comment">// send the rpc request</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"connection has been closed"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">      LOG.warn(<span class="string">"interrupted waiting to send rpc request to server"</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tag4---------------------</span></span><br><span class="line"><span class="function">Call <span class="title">createCall</span><span class="params">(RpcKind rpcKind, Writable rpcRequest)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个内部类Call</span></span><br><span class="line"><span class="comment">//Writable rpcRequest封装了方法的名字、client版本还有有关方法的一组数据。。。存疑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Call(rpcKind, rpcRequest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回到tag4---</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//进入tag5</span></span><br><span class="line"><span class="comment">//Get a connection from the pool, or create a new one and add it to the pool.相同的ID可以重用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是Client类中的方法</span></span><br><span class="line"><span class="comment">//ConnectionId remoteId远程的ip和端口</span></span><br><span class="line"><span class="comment">//Call call 之前创建的一个类封装了方法名和参数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">getConnection</span><span class="params">(ConnectionId remoteId,</span></span></span><br><span class="line"><span class="function"><span class="params">      Call call, <span class="keyword">int</span> serviceClass, AtomicBoolean fallbackToSimpleAuth)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!running.get()) &#123;</span><br><span class="line">      <span class="comment">// the client is stopped</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"The client is stopped"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Connection connection;</span><br><span class="line">    <span class="comment">/* we could avoid this allocation for each RPC by having a  </span></span><br><span class="line"><span class="comment">     * connectionsId object and with set() method. We need to manage the</span></span><br><span class="line"><span class="comment">     * refs for keys in HashMap properly. For now its ok.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (connections) &#123;</span><br><span class="line">        connection = connections.get(remoteId);</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//tag6---------</span></span><br><span class="line">          connection = <span class="keyword">new</span> Connection(remoteId, serviceClass);</span><br><span class="line">          connections.put(remoteId, connection);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//tag7----------------</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!connection.addCall(call));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//we don't invoke the method below inside "synchronized (connections)"</span></span><br><span class="line">    <span class="comment">//block above. The reason for that is if the server happens to be slow,</span></span><br><span class="line">    <span class="comment">//it will take longer to establish a connection and that will slow the</span></span><br><span class="line">    <span class="comment">//entire system down.</span></span><br><span class="line">    <span class="comment">//tag8----------------------</span></span><br><span class="line">    connection.setupIOstreams(fallbackToSimpleAuth);</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tag6进入-------------------</span></span><br><span class="line"><span class="comment">//非常重要的client的内部类reactor模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Connection</span><span class="params">(ConnectionId remoteId, <span class="keyword">int</span> serviceClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//第一次进来为null</span></span><br><span class="line">      <span class="keyword">this</span>.remoteId = remoteId;</span><br><span class="line">      <span class="keyword">this</span>.server = remoteId.getAddress();</span><br><span class="line">      <span class="keyword">if</span> (server.isUnresolved()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> NetUtils.wrapException(server.getHostName(),</span><br><span class="line">            server.getPort(),</span><br><span class="line">            <span class="keyword">null</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="keyword">new</span> UnknownHostException());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.rpcTimeout = remoteId.getRpcTimeout();</span><br><span class="line">      <span class="keyword">this</span>.maxIdleTime = remoteId.getMaxIdleTime();</span><br><span class="line">      <span class="keyword">this</span>.connectionRetryPolicy = remoteId.connectionRetryPolicy;</span><br><span class="line">      <span class="keyword">this</span>.maxRetriesOnSasl = remoteId.getMaxRetriesOnSasl();</span><br><span class="line">      <span class="keyword">this</span>.maxRetriesOnSocketTimeouts = remoteId.getMaxRetriesOnSocketTimeouts();</span><br><span class="line">      <span class="keyword">this</span>.tcpNoDelay = remoteId.getTcpNoDelay();</span><br><span class="line">      <span class="keyword">this</span>.doPing = remoteId.getDoPing();</span><br><span class="line">      <span class="comment">//先Ping？有意思。。。。。。。true</span></span><br><span class="line"><span class="comment">//------------下方高能底层操作以后慢慢来</span></span><br><span class="line">      <span class="keyword">if</span> (doPing) &#123;</span><br><span class="line">        <span class="comment">// construct a RPC header with the callId as the ping callId</span></span><br><span class="line">        pingRequest = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        RpcRequestHeaderProto pingHeader = ProtoUtil</span><br><span class="line">            .makeRpcRequestHeader(RpcKind.RPC_PROTOCOL_BUFFER,</span><br><span class="line">                OperationProto.RPC_FINAL_PACKET, PING_CALL_ID,</span><br><span class="line">                RpcConstants.INVALID_RETRY_COUNT, clientId);</span><br><span class="line">        pingHeader.writeDelimitedTo(pingRequest);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">// how often sends ping to the server in msecs</span></span><br><span class="line">     <span class="comment">//60000</span></span><br><span class="line">      <span class="keyword">this</span>.pingInterval = remoteId.getPingInterval();</span><br><span class="line">      <span class="keyword">this</span>.serviceClass = serviceClass;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">"The ping interval is "</span> + <span class="keyword">this</span>.pingInterval + <span class="string">" ms."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//"123,Sim"和上方的一样的ticket还有RemoteId这个类</span></span><br><span class="line">      UserGroupInformation ticket = remoteId.getTicket();</span><br><span class="line">      <span class="comment">//高能操作----SASL全称Simple Authentication and Security Layer，是一种用来扩充C/S模式验证能力的机制。在Postfix可以利用SASL来判断用户是否有权使用转发服务，或是辨认谁在使用你的服务器</span></span><br><span class="line">      <span class="comment">// try SASL if security is enabled or if the ugi contains tokens.</span></span><br><span class="line">      <span class="comment">// this causes a SIMPLE client with tokens to attempt SASL</span></span><br><span class="line">      <span class="keyword">boolean</span> trySasl = UserGroupInformation.isSecurityEnabled() ||</span><br><span class="line">                        (ticket != <span class="keyword">null</span> &amp;&amp; !ticket.getTokens().isEmpty());</span><br><span class="line">      <span class="keyword">this</span>.authProtocol = trySasl ? AuthProtocol.SASL : AuthProtocol.NONE;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.setName(<span class="string">"IPC Client ("</span> + socketFactory.hashCode() +<span class="string">") connection to "</span> +</span><br><span class="line">          server.toString() +</span><br><span class="line">          <span class="string">" from "</span> + ((ticket==<span class="keyword">null</span>)?<span class="string">"an unknown user"</span>:ticket.getUserName()));</span><br><span class="line">      <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tag6-------------完成回到一开始的tag6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//tag7-------------进入</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add a call to this connection's call queue and notify</span></span><br><span class="line"><span class="comment">     * a listener; synchronized.</span></span><br><span class="line"><span class="comment">     * Returns false if called during shutdown.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> call to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the call was added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addCall</span><span class="params">(Call call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (shouldCloseConnection.get())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// currently active calls</span></span><br><span class="line">      calls.put(call.id, call);</span><br><span class="line">      notify();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//tag7-------------退出</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//tag8-------------进入</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setupIOstreams</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AtomicBoolean fallbackToSimpleAuth)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (socket != <span class="keyword">null</span> || shouldCloseConnection.get()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(<span class="string">"Connecting to "</span>+server);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTracing()) &#123;</span><br><span class="line">          Trace.addTimelineAnnotation(<span class="string">"IPC client connecting to "</span> + server);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">short</span> numRetries = <span class="number">0</span>;</span><br><span class="line">        Random rand = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          setupConnection();</span><br><span class="line">          InputStream inStream = NetUtils.getInputStream(socket);</span><br><span class="line">          OutputStream outStream = NetUtils.getOutputStream(socket);</span><br><span class="line">          writeConnectionHeader(outStream);</span><br><span class="line">          <span class="keyword">if</span> (authProtocol == AuthProtocol.SASL) &#123;</span><br><span class="line">            <span class="keyword">final</span> InputStream in2 = inStream;</span><br><span class="line">            <span class="keyword">final</span> OutputStream out2 = outStream;</span><br><span class="line">            UserGroupInformation ticket = remoteId.getTicket();</span><br><span class="line">            <span class="keyword">if</span> (ticket.getRealUser() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ticket = ticket.getRealUser();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              authMethod = ticket</span><br><span class="line">                  .doAs(<span class="keyword">new</span> PrivilegedExceptionAction&lt;AuthMethod&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> AuthMethod <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> setupSaslConnection(in2, out2);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">              authMethod = saslRpcClient.getAuthMethod();</span><br><span class="line">              <span class="keyword">if</span> (rand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                rand = <span class="keyword">new</span> Random();</span><br><span class="line">              &#125;</span><br><span class="line">              handleSaslConnectionFailure(numRetries++, maxRetriesOnSasl, ex,</span><br><span class="line">                  rand, ticket);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (authMethod != AuthMethod.SIMPLE) &#123;</span><br><span class="line">              <span class="comment">// Sasl connect is successful. Let's set up Sasl i/o streams.</span></span><br><span class="line">              inStream = saslRpcClient.getInputStream(inStream);</span><br><span class="line">              outStream = saslRpcClient.getOutputStream(outStream);</span><br><span class="line">              <span class="comment">// for testing</span></span><br><span class="line">              remoteId.saslQop =</span><br><span class="line">                  (String)saslRpcClient.getNegotiatedProperty(Sasl.QOP);</span><br><span class="line">              LOG.debug(<span class="string">"Negotiated QOP is :"</span> + remoteId.saslQop);</span><br><span class="line">              <span class="keyword">if</span> (fallbackToSimpleAuth != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fallbackToSimpleAuth.set(<span class="keyword">false</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UserGroupInformation.isSecurityEnabled()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!fallbackAllowed) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Server asks us to fall back to SIMPLE "</span> +</span><br><span class="line">                    <span class="string">"auth, but this client is configured to only allow secure "</span> +</span><br><span class="line">                    <span class="string">"connections."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (fallbackToSimpleAuth != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fallbackToSimpleAuth.set(<span class="keyword">true</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">if</span> (doPing) &#123;</span><br><span class="line">            inStream = <span class="keyword">new</span> PingInputStream(inStream);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(inStream));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// SASL may have already buffered the stream</span></span><br><span class="line">          <span class="keyword">if</span> (!(outStream <span class="keyword">instanceof</span> BufferedOutputStream)) &#123;</span><br><span class="line">            outStream = <span class="keyword">new</span> BufferedOutputStream(outStream);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.out = <span class="keyword">new</span> DataOutputStream(outStream);</span><br><span class="line">          </span><br><span class="line">          writeConnectionContext(remoteId, authMethod);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// update last activity time</span></span><br><span class="line">          touch();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Trace.isTracing()) &#123;</span><br><span class="line">            Trace.addTimelineAnnotation(<span class="string">"IPC client connected to "</span> + server);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// start the receiver thread after the socket connection has been set</span></span><br><span class="line">          <span class="comment">// up</span></span><br><span class="line">          start();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">          markClosed((IOException)t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          markClosed(<span class="keyword">new</span> IOException(<span class="string">"Couldn't set up IO streams"</span>, t));</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//tag8-------------退出</span></span><br></pre></td></tr></table></figure><p>namenode启动时会在初始化方法中创造NameNodeRpcServer对象的实例 这个实例对象构造函数会通过创建RPC.Builder内部类的静态实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">this</span>.clientRpcServer = <span class="keyword">new</span> RPC.Builder(conf)</span><br><span class="line">        .setProtocol(</span><br><span class="line">            org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolPB.class)</span><br><span class="line">        .setInstance(clientNNPbService).setBindAddress(bindHost)</span><br><span class="line">        .setPort(rpcAddr.getPort()).setNumHandlers(handlerCount)</span><br><span class="line">        .setVerbose(<span class="keyword">false</span>)</span><br><span class="line">        .setSecretManager(namesystem.getDelegationTokenSecretManager()).build();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;先从最基本的RPC调用的源码开始着手&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://www.shadowerli.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="https://www.shadowerli.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>安全检测</title>
    <link href="https://www.shadowerli.com/2018/05/03/2018-5-3%20/"/>
    <id>https://www.shadowerli.com/2018/05/03/2018-5-3 /</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-12-11T13:40:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>某比赛要求在施工通过监控对没带安全帽的人进行报警<br><a id="more"></a><br>先吐槽一下比赛的主办方、给的测试视屏画质极低拍摄极为敷衍、有些人连人眼都无法识别是否带了安全帽、这小小的比赛大概整了整个51假期吧、</excerpt></p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>这里主要提供一下思路、传统ssd(高配电脑fater-rcnn走起)+inception3、你可能会问为什么不直接用ssd进行二次训练就好了、我当初也是这么想的这不是很简单么、<br>然后我先把视频一帧帧的读取并转化成图像然后手动lable(这里有个问题就是一个图像中有多个人这样训练的时候会不会造成无法收敛？我觉得会有很大的影响)、<br>然后训练这个像打了码一样的图片(再次吐槽一下主办方)、结果连人都识别不出来！！！内心极度奔溃、然后就用了独创非主流方法</p><h2 id="具体步骤-非主流方法请勿模仿、"><a href="#具体步骤-非主流方法请勿模仿、" class="headerlink" title="具体步骤(非主流方法请勿模仿、)"></a>具体步骤(非主流方法请勿模仿、)</h2><p>鉴于之前连人都识别出来的问题、我就直接调用ssd先去除人、然后对有戴和没戴安全帽的进行训练(通过inception3)、然后运行通过ssd的目标检测结果输入到inception3中进行判别<br>判别的结果传给之前的显示字符串然后进行输出、下面附上源码(目录与object_detection一致)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#视频的读取得到识别物体后显示出来</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils.app_utils <span class="keyword">import</span> FPS</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> vis_util</span><br><span class="line"></span><br><span class="line">CWD_PATH = os.getcwd()</span><br><span class="line"></span><br><span class="line">MODEL_NAME = <span class="string">'ssd_mobilenet_v1_coco_11_06_2017'</span></span><br><span class="line">PATH_TO_CKPT = os.path.join(CWD_PATH, <span class="string">'object_detection'</span>, MODEL_NAME, <span class="string">'frozen_inference_graph.pb'</span>)</span><br><span class="line">PATH_TO_LABELS = os.path.join(CWD_PATH, <span class="string">'object_detection'</span>, <span class="string">'data'</span>, <span class="string">'mscoco_label_map.pbtxt'</span>)</span><br><span class="line"></span><br><span class="line">NUM_CLASSES = <span class="number">2</span></span><br><span class="line">label_map = label_map_util.load_labelmap(PATH_TO_LABELS)</span><br><span class="line"></span><br><span class="line">categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES,</span><br><span class="line">                                                            use_display_name=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">category_index = label_map_util.create_category_index(categories)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_objects</span><span class="params">(image_np, sess, detection_graph)</span>:</span></span><br><span class="line">    <span class="comment"># 增加输入图像的维度: [1, None, None, 3]</span></span><br><span class="line">    image_np_expanded = np.expand_dims(image_np, axis=<span class="number">0</span>)</span><br><span class="line">    image_tensor = detection_graph.get_tensor_by_name(<span class="string">'image_tensor:0'</span>)</span><br><span class="line">    <span class="comment"># 得到检测框</span></span><br><span class="line">    boxes = detection_graph.get_tensor_by_name(<span class="string">'detection_boxes:0'</span>)</span><br><span class="line">    <span class="comment">#得到他的得分</span></span><br><span class="line">    scores = detection_graph.get_tensor_by_name(<span class="string">'detection_scores:0'</span>)</span><br><span class="line">    classes = detection_graph.get_tensor_by_name(<span class="string">'detection_classes:0'</span>)</span><br><span class="line">    num_detections = detection_graph.get_tensor_by_name(<span class="string">'num_detections:0'</span>)</span><br><span class="line">    <span class="comment"># Actual detection.</span></span><br><span class="line">    <span class="comment"># 这里的class是包含多个识别种类的二维数组</span></span><br><span class="line">    <span class="comment">#[[100,4]]boxes 每个框的位置坐标,    scores 100个 ,     classes 100个 ,    num_detections 100个</span></span><br><span class="line">    (boxes, scores, classes, num_detections) = sess.run(</span><br><span class="line">        [boxes, scores, classes, num_detections],</span><br><span class="line">        feed_dict=&#123;image_tensor: image_np_expanded&#125;)</span><br><span class="line">    <span class="comment"># Visualization of the results of a detection.</span></span><br><span class="line">    vis_util.visualize_boxes_and_labels_on_image_array(</span><br><span class="line">        image_np,</span><br><span class="line">        np.squeeze(boxes),</span><br><span class="line">        np.squeeze(classes).astype(np.int32),</span><br><span class="line">        np.squeeze(scores),</span><br><span class="line">        category_index,</span><br><span class="line">        use_normalized_coordinates=<span class="keyword">True</span>,</span><br><span class="line">        line_thickness=<span class="number">4</span>,</span><br><span class="line">        min_score_thresh=<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> image_np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    detection_graph = tf.Graph()</span><br><span class="line">    <span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">        od_graph_def = tf.GraphDef()</span><br><span class="line">        <span class="keyword">with</span> tf.gfile.GFile(PATH_TO_CKPT, <span class="string">'rb'</span>) <span class="keyword">as</span> fid:</span><br><span class="line">            serialized_graph = fid.read()</span><br><span class="line">            od_graph_def.ParseFromString(serialized_graph)</span><br><span class="line">            tf.import_graph_def(od_graph_def, name=<span class="string">''</span>)</span><br><span class="line">    sess = tf.Session(graph=detection_graph)</span><br><span class="line">    video_capture = cv2.VideoCapture(<span class="string">'b.mp4'</span>)</span><br><span class="line">    fps = FPS().start()</span><br><span class="line">    frame_width = int(video_capture.get(<span class="number">3</span>))</span><br><span class="line">    frame_height = int(video_capture.get(<span class="number">4</span>))</span><br><span class="line">    <span class="comment"># define video output</span></span><br><span class="line">    out = cv2.VideoWriter(<span class="string">'outpy.mp4'</span>, cv2.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>), <span class="number">10</span>, (frame_width, frame_height))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> video_capture.isOpened():</span><br><span class="line">        ret, frame = video_capture.read()</span><br><span class="line">        t = time.time()</span><br><span class="line">        detected_image = detect_objects(frame, sess, detection_graph)</span><br><span class="line">        fps.update()</span><br><span class="line">        cv2.imshow(<span class="string">'Video'</span>, detected_image)</span><br><span class="line"><span class="comment">#本来想来做个更加流畅的优化、就是格一个帧进行识别、但还是会阻塞</span></span><br><span class="line">        <span class="comment">#if count % 100 == 0:</span></span><br><span class="line">        <span class="comment">#    print(count)</span></span><br><span class="line">        <span class="comment"># write to video file</span></span><br><span class="line">        <span class="comment">#out.write(detected_image)</span></span><br><span class="line">        <span class="comment"># print('[INFO] elapsed time: &#123;:.2f&#125;'.format(time.time() - t))</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    fps.stop()</span><br><span class="line">    video_capture.release()</span><br><span class="line">    sess.close()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#visualization_untils</span></span><br><span class="line"><span class="comment">#第160行进行如下修改、check为inception3的入口、将图片和坐标传入</span></span><br><span class="line">  <span class="keyword">if</span> use_normalized_coordinates:</span><br><span class="line">    (left, right, top, bottom) = (xmin * im_width, xmax * im_width,</span><br><span class="line">                                  ymin * im_height, ymax * im_height)</span><br><span class="line">    </span><br><span class="line">    name=check(image.copy(), left, right, top, bottom)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##188 行处</span></span><br><span class="line"><span class="comment">#name为全局变量、接受inception3识别结果的字符串</span></span><br><span class="line">draw.text(</span><br><span class="line">        (left + margin, text_bottom - text_height - margin),</span><br><span class="line">        name,</span><br><span class="line">        fill=<span class="string">'black'</span>,</span><br><span class="line">        font=font)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#check模块、inception3的入口</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(image,left, right, top, bottom)</span>:</span></span><br><span class="line">    got = array(image)</span><br><span class="line">    crop_img = got[int(top):int(bottom), int(left):int(right), <span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">#载入之前自己训练的模型</span></span><br><span class="line">    <span class="keyword">with</span> tf.gfile.FastGFile(<span class="string">'output_graph.pb'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        graph_def = tf.GraphDef()</span><br><span class="line">        graph_def.ParseFromString(f.read())</span><br><span class="line">        tf.import_graph_def(graph_def, name=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        softmax_tensor = sess.graph.get_tensor_by_name(<span class="string">'final_result:0'</span>)</span><br><span class="line"><span class="comment">#将传入的图片格式转化一下</span></span><br><span class="line">        first = tf.image.convert_image_dtype(crop_img, dtype=tf.float32)</span><br><span class="line">        <span class="comment"># jpeg 进行编码</span></span><br><span class="line">        <span class="comment"># eval()想当于将tensorflow的存储格式中提取出来以数组的格式</span></span><br><span class="line">        encode = tf.image.encode_jpeg(first.eval())</span><br><span class="line">        <span class="comment">#将编码好的图片传入以decodejpeg的格式</span></span><br><span class="line">        predictions = sess.run(softmax_tensor, &#123;<span class="string">'DecodeJpeg/contents:0'</span>: encode.eval()&#125;)  <span class="comment"># 图片格式是jpeg格式</span></span><br><span class="line">        predictions = np.squeeze(predictions)  <span class="comment"># 把结果转为1维数据</span></span><br><span class="line">        top_k = predictions.argsort()[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> top_k[<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">            human_string=<span class="string">"unsafe"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            human_string=<span class="string">"safe"</span></span><br><span class="line">        <span class="keyword">return</span> human_string</span><br><span class="line">        <span class="comment">#返回给画框的代码</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似十分完美流程的过程在实际运行时由于笔记本配置低下(好想要GPU的台式机！！)、换了一台配置稍微高一点的本、但还是崩了、tensorflow开两个session的内存消耗比想象中的要大、开<br>看来这操作只能是活在梦里了、希望以后能想出一种底层之间的优化(相比之前的已经做了很多IO的优化、但主要问题还是这是线性的操作、一定有卡顿来进行二次判断)</p><h2 id="更新！！！"><a href="#更新！！！" class="headerlink" title="更新！！！"></a>更新！！！</h2><p>终于找到了问题所在！！原来每一帧的图像传入后都要重新加载一次graph！！所以导致内存直接爆炸！改动后可以跑的动了、但比较吃配置配置高一点的话可以更加流畅吧、<br>具体改动如下、其余的改动就是要在每个调用的visualization_utils中的函数里传入初始化的graph、具体修改如下、整个项目会放到github上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主要是对main函数下的修改vediondetection.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#tf.Graph()生成新的图</span></span><br><span class="line">    detection_graph = tf.Graph()</span><br><span class="line">    inceptionsess =tf.Graph()</span><br><span class="line">    <span class="keyword">with</span> inceptionsess.as_default():</span><br><span class="line">        od_graph_def = tf.GraphDef()</span><br><span class="line">        <span class="keyword">with</span> tf.gfile.FastGFile(<span class="string">'output_graph.pb'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            serialized_graph = f.read()</span><br><span class="line">            od_graph_def.ParseFromString(serialized_graph)</span><br><span class="line">            tf.import_graph_def(od_graph_def, name=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> detection_graph.as_default():</span><br><span class="line">        od_graph_def = tf.GraphDef()</span><br><span class="line">        <span class="keyword">with</span> tf.gfile.GFile(PATH_TO_CKPT, <span class="string">'rb'</span>) <span class="keyword">as</span> fid:</span><br><span class="line">            serialized_graph = fid.read()</span><br><span class="line">            od_graph_def.ParseFromString(serialized_graph)</span><br><span class="line">            tf.import_graph_def(od_graph_def, name=<span class="string">''</span>)</span><br><span class="line">    sess = tf.Session(graph=detection_graph)</span><br><span class="line">    video_capture = cv2.VideoCapture(<span class="string">'b.mp4'</span>)</span><br><span class="line">    fps = FPS().start()</span><br><span class="line">    frame_width = int(video_capture.get(<span class="number">3</span>))</span><br><span class="line">    frame_height = int(video_capture.get(<span class="number">4</span>))</span><br><span class="line">    <span class="comment"># define video output</span></span><br><span class="line">    out = cv2.VideoWriter(<span class="string">'outpy.mp4'</span>, cv2.VideoWriter_fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'P'</span>, <span class="string">'G'</span>), <span class="number">10</span>, (frame_width, frame_height))</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> video_capture.isOpened():</span><br><span class="line">        ret, frame = video_capture.read()</span><br><span class="line">        t = time.time()</span><br><span class="line">        detected_image = detect_objects(frame, sess, detection_graph,inceptionsess)</span><br><span class="line">        fps.update()</span><br><span class="line">        out.write(detected_image)</span><br><span class="line">        cv2.imshow(<span class="string">'Video'</span>, detected_image)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    fps.stop()</span><br><span class="line">    video_capture.release()</span><br><span class="line">    sess.close()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对checker类的方法进行的改动</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(image,left, right, top, bottom,inceptionsess)</span>:</span></span><br><span class="line">    got = array(image)</span><br><span class="line">    crop_img = got[int(top):int(bottom), int(left):int(right), <span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># with tf.gfile.FastGFile('output_graph.pb', 'rb') as f:</span></span><br><span class="line">    <span class="comment">#     graph_def = tf.GraphDef()</span></span><br><span class="line">    <span class="comment">#     graph_def.ParseFromString(f.read())</span></span><br><span class="line">    <span class="comment">#     tf.import_graph_def(graph_def, name='')</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session(graph=inceptionsess) <span class="keyword">as</span> sess:</span><br><span class="line">        softmax_tensor = sess.graph.get_tensor_by_name(<span class="string">'final_result:0'</span>)</span><br><span class="line">        <span class="comment"># jpeg 进行编码</span></span><br><span class="line">        <span class="comment"># """Return the value of the tensor represented by this handle.""</span></span><br><span class="line">        encode = tf.image.encode_jpeg(crop_img)</span><br><span class="line">        predictions = sess.run(softmax_tensor, &#123;<span class="string">'DecodeJpeg/contents:0'</span>: encode.eval()&#125;)  <span class="comment"># 图片格式是jpg格式</span></span><br><span class="line">        predictions = np.squeeze(predictions)  <span class="comment"># 把结果转为1维数据</span></span><br><span class="line">        top_k = predictions.argsort()[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> top_k[<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">            human_string=<span class="string">"unsafe"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            human_string=<span class="string">"safe"</span></span><br><span class="line">        <span class="keyword">return</span> human_string</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;某比赛要求在施工通过监控对没带安全帽的人进行报警&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.shadowerli.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="图像识别" scheme="https://www.shadowerli.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>定点识别</title>
    <link href="https://www.shadowerli.com/2018/04/08/2018-4-8/"/>
    <id>https://www.shadowerli.com/2018/04/08/2018-4-8/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-12-11T13:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>基于object_detection训练自己的模型<br><a id="more"></a><br>花了不知道多少天、、主要参加一个定点识别的比赛、算是把模型搞定了、虽然结果十分的令人喜感（哈哈、不说了）、、难度有一点大（主要是各种天坑、在这里记录一下）</excerpt></p><p>这是阿里天池的比赛、比赛给出上万张图片主要是服装、要在每个图片上识别出服装每个关键点、并将识别结果的坐标输出、比如左袖口什么的、差不多有24个标签吧、训练集给出的是每个图片的所有关键点的坐标、我的思路是先根据坐标<br>转化成矩形框(同时对x和y加上自己定义的距离数)、然后通过object_detection确定定位的位置、最后在进行输出(求两个x和两个y的平均来得到中心点)、具体步骤如下：</p><h2 id="根据lable切分图片"><a href="#根据lable切分图片" class="headerlink" title="根据lable切分图片"></a>根据lable切分图片</h2><p>这个脚本主要是根据lable对图片进行切分、根据lable创建若干个文件夹、切好的图片放到每个对应的文件加下、切分完得到几十万张图片(此刻的内心是奔溃的)、<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path=os.getcwd()</span><br><span class="line"><span class="comment">#自己定义框的宽度wide</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawcnts_and_cut</span><span class="params">(original_img,x,y,wide)</span>:</span></span><br><span class="line">    x1=x-wide</span><br><span class="line">    x2=x+wide</span><br><span class="line">    y1=y-wide</span><br><span class="line">    y2=y+wide</span><br><span class="line">    crop_img = original_img[y1:y2, x1:x2]</span><br><span class="line">    <span class="keyword">return</span>  crop_img</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(img_path,save_path,x,y)</span>:</span></span><br><span class="line">    original_img= cv2.imread(img_path)</span><br><span class="line">    crop_img = drawcnts_and_cut(original_img,int(x),int(y),<span class="number">25</span>)</span><br><span class="line">    cv2.imwrite(save_path, crop_img)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datatranslate</span><span class="params">(data)</span>:</span></span><br><span class="line">    splited=str(data).split()</span><br><span class="line">    <span class="keyword">return</span> splited[<span class="number">0</span>],splited[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#自己根据标签数量来改</span></span><br><span class="line">lable=[<span class="string">'class1'</span>, <span class="string">'class2'</span>]</span><br><span class="line">csv_reader = csv.reader(open(<span class="string">'train\\input.csv'</span>, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">num=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">26</span>,<span class="number">1</span>):</span><br><span class="line">        photo=row[<span class="number">0</span>]</span><br><span class="line">        data=row[i]</span><br><span class="line">        category=lable[i]</span><br><span class="line">        splited = str(row[i]).split(<span class="string">"_"</span>)</span><br><span class="line">        print(photo)</span><br><span class="line">        print(num)</span><br><span class="line">        <span class="keyword">if</span> int(splited[<span class="number">0</span>])!=<span class="number">-1</span>:</span><br><span class="line">            lib = path + <span class="string">"\\train\\"</span>+photo</span><br><span class="line">            savepath=path+<span class="string">"\\output\\"</span>+str(category)+<span class="string">"\\"</span>+str(category)+<span class="string">"+"</span>+str(num)+<span class="string">".jpg"</span></span><br><span class="line">            num+=<span class="number">1</span></span><br><span class="line">            start(lib,savepath,splited[<span class="number">0</span>],splited[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><h2 id="将图片转化为对应的xml文件"><a href="#将图片转化为对应的xml文件" class="headerlink" title="将图片转化为对应的xml文件"></a>将图片转化为对应的xml文件</h2><p>默认的边框大小为整个图片的d、长度和宽度可以从图片中获取、最终批量的生成xml文件（突然想起比赛的图片切分后生成的30万个文件、还只能分批次的复制、一复制就卡屏、迷醉、、）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据实际来添加class</span></span><br><span class="line">list=[<span class="string">"class1"</span>,<span class="string">"class2"</span>]</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> list:</span><br><span class="line">    path=os.getcwd()</span><br><span class="line">    <span class="comment">#图像存储位置</span></span><br><span class="line">    src_img_dir = path+<span class="string">"\\input2\\"</span>+a</span><br><span class="line">    <span class="comment"># xml文件存放位置</span></span><br><span class="line">    src_xml_dir = path+<span class="string">"\\input2\\"</span>+a</span><br><span class="line">    img_Lists = glob.glob(src_img_dir + <span class="string">'\*.jpg'</span>)</span><br><span class="line">    img_basenames = [] </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> img_Lists:</span><br><span class="line">        img_basenames.append(os.path.basename(item))</span><br><span class="line">    img_names = [] </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> img_basenames:</span><br><span class="line">        temp1, temp2 = os.path.splitext(item)</span><br><span class="line">        img_names.append(temp1)</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> img_names:</span><br><span class="line">        im = Image.open((src_img_dir + <span class="string">'/'</span> + img + <span class="string">'.jpg'</span>))</span><br><span class="line">        width, height = im.size</span><br><span class="line">        xml_file = open((src_xml_dir + <span class="string">'/'</span> + img + <span class="string">'.xml'</span>), <span class="string">'w'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'&lt;annotation&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'    &lt;folder&gt;'</span>+a+<span class="string">'&lt;/folder&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'    &lt;filename&gt;'</span> + str(img) + <span class="string">'.jpg'</span> + <span class="string">'&lt;/filename&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'    &lt;path&gt;'</span> + path +<span class="string">"\\input2\\"</span>+a+<span class="string">"\\"</span>+ str(img) + <span class="string">'.jpg'</span>+ <span class="string">'&lt;/path&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'    &lt;size&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;width&gt;'</span> + str(width) + <span class="string">'&lt;/width&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;height&gt;'</span> + str(height) + <span class="string">'&lt;/height&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;depth&gt;3&lt;/depth&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'    &lt;/size&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;segmented&gt;0&lt;/segmented&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'    &lt;object&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;name&gt;'</span> + str(img) + <span class="string">'&lt;/name&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;pose&gt;Unspecified&lt;/pose&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;truncated&gt;1&lt;/truncated&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;difficult&gt;0&lt;/difficult&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;bndbox&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'            &lt;xmin&gt;'</span> + <span class="string">"0"</span> + <span class="string">'&lt;/xmin&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'            &lt;ymin&gt;'</span> + <span class="string">"0"</span> + <span class="string">'&lt;/ymin&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'            &lt;xmax&gt;'</span> + str(width) + <span class="string">'&lt;/xmax&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'            &lt;ymax&gt;'</span> + str(height) + <span class="string">'&lt;/ymax&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'        &lt;/bndbox&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'    &lt;/object&gt;\n'</span>)</span><br><span class="line">        xml_file.write(<span class="string">'&lt;/annotation&gt;'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="xml转csv文件合并csv文件"><a href="#xml转csv文件合并csv文件" class="headerlink" title="xml转csv文件合并csv文件"></a>xml转csv文件合并csv文件</h2><p>要使用如下脚本将xml文件转化为csv文件、最后再把每个目录下的csv文件进行合并（注意删除重复的lable）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#xml转csv文件合并csv文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line">tag=[<span class="string">'class1'</span>,<span class="string">'class2'</span>]</span><br><span class="line">num=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xml_to_csv</span><span class="params">(path)</span>:</span></span><br><span class="line">    xml_list = []</span><br><span class="line">    <span class="keyword">for</span> xml_file <span class="keyword">in</span> glob.glob(path + <span class="string">'/*.xml'</span>):</span><br><span class="line">        tree = ET.parse(xml_file)</span><br><span class="line">        root = tree.getroot()</span><br><span class="line">        <span class="keyword">for</span> member <span class="keyword">in</span> root.findall(<span class="string">'object'</span>):</span><br><span class="line">            value = (root.find(<span class="string">'filename'</span>).text,</span><br><span class="line">                     int(root.find(<span class="string">'size'</span>)[<span class="number">0</span>].text),</span><br><span class="line">                     int(root.find(<span class="string">'size'</span>)[<span class="number">1</span>].text),</span><br><span class="line">                     root.find(<span class="string">'folder'</span>).text,</span><br><span class="line">                     int(member[<span class="number">4</span>][<span class="number">0</span>].text),</span><br><span class="line">                     int(member[<span class="number">4</span>][<span class="number">1</span>].text),</span><br><span class="line">                     int(member[<span class="number">4</span>][<span class="number">2</span>].text),</span><br><span class="line">                     int(member[<span class="number">4</span>][<span class="number">3</span>].text)</span><br><span class="line">                     )</span><br><span class="line">            xml_list.append(value)</span><br><span class="line">    column_name = [<span class="string">'filename'</span>, <span class="string">'width'</span>, <span class="string">'height'</span>, <span class="string">'class'</span>, <span class="string">'xmin'</span>, <span class="string">'ymin'</span>, <span class="string">'xmax'</span>, <span class="string">'ymax'</span>]</span><br><span class="line">    xml_df = pd.DataFrame(xml_list, columns=column_name)</span><br><span class="line">    <span class="keyword">return</span> xml_df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> tag:</span><br><span class="line">        image_path = os.path.join(os.getcwd(), <span class="string">'input2\\'</span>+a)</span><br><span class="line">        xml_df = xml_to_csv(image_path)</span><br><span class="line">        xml_df.to_csv(<span class="string">'data\\'</span>+str(a)+<span class="string">'.csv'</span>,index=<span class="keyword">None</span>)</span><br><span class="line">        print(<span class="string">'Successfully converted xml to csv.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>通过shell批量合并csv<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">E:</span><br><span class="line">cd add</span><br><span class="line">dir</span><br><span class="line">copy *.csv all_keywords.csv</span><br><span class="line">echo 合并成功！'</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></p><h2 id="调用object-detection前的准备"><a href="#调用object-detection前的准备" class="headerlink" title="调用object_detection前的准备"></a>调用object_detection前的准备</h2><p>下面是很有参考性的博客和官方的地址<br><a href="https://blog.csdn.net/honk2012/article/details/79099651" target="_blank" rel="noopener">https://blog.csdn.net/honk2012/article/details/79099651</a><br><a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/installation.md" target="_blank" rel="noopener">https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/installation.md</a><br>可以翻墙的话推荐下面这篇、这个towardsdatascience还是很不错的<br><a href="https://towardsdatascience.com/how-to-train-your-own-object-detector-with-tensorflows-object-detector-api-bec72ecfe1d9" target="_blank" rel="noopener">https://towardsdatascience.com/how-to-train-your-own-object-detector-with-tensorflows-object-detector-api-bec72ecfe1d9</a><br>基本后面的训练和模型的调用都是在github上的、想普通的个人电脑用ssd的一个mobile就行了、别的根本跑不动、batch设置的越大每次迭代的时间越长、如果太大电脑配置不够的话你就可以重新开机了、、<br>顺便说说几个坑官方步骤中的 protoc object_detection/protos/*.proto –python_out=. 如果是在window下要下载3.4版本的3.5会有bug<br>object_detection初始化一定要先执行、不然会给你各种报错、、<br>官方文档中export PYTHONPATH=$PYTHONPATH:<code>pwd</code>:<code>pwd</code>/slim  如果是windows下执行要用这个命令(查了很久用了很多的坑爹方法、只能说项目对windows不友好)SET PYTHONPATH=%cd%;%cd%\slim  执行目录还是不变<br>注意这几个坑基本就会很顺畅了、还有一些其他小坑一时想不起来、想到了再加、</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;基于object_detection训练自己的模型&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.shadowerli.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="图像识别" scheme="https://www.shadowerli.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>博客搬家</title>
    <link href="https://www.shadowerli.com/2018/03/23/2018-3-23/"/>
    <id>https://www.shadowerli.com/2018/03/23/2018-3-23/</id>
    <published>2018-03-22T16:00:00.000Z</published>
    <updated>2018-03-23T12:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>无意间看到了Hexo的这个黑蓝主题、实在是太cool了！！抽空用了两个晚上搬家<br><a id="more"></a><br>原来的博客一直是用的是jekyll(差点又拼错、)、还是很方便不过还是有很多弊端</excerpt></p><p>1、代码高亮、现在看看原来的博客这代码高亮、、简直无法直视、虽然后来另外装了插件但还是惨不忍睹(主要是这个主题的高亮真的是太漂亮了、看了会上瘾、、)<br>2、由于原来的博客用的是老外的主题为了实现想要的效果文字间的空格符有点受不了、十分影响美观、还有字体(这里支持一下国产、、)<br>3、这个主题有分类功能、随着博客的增多查找也比原来的方便、<br>4、也是主要原因、、就是想换、笑死、、、</p><p>现在终于换好了、过程也十分折腾、也遇到了各种坑、什么Hexo的版本问题、server要独立安装、、、希望这博客可以用几年吧、、同时再次感谢maochunguang提供的主题</p><p>前端真的是一个十分神奇的东西、、但真的没工夫投在上面学了、还有评论功能、看了大佬的主题demo觉得加了评论就不是十分洁简了、于是就不做了（绝不是因为懒）、、</p><p>最后注意我的背景:它是会变的哦、、、</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;无意间看到了Hexo的这个黑蓝主题、实在是太cool了！！抽空用了两个晚上搬家&lt;br&gt;
    
    </summary>
    
      <category term="other" scheme="https://www.shadowerli.com/categories/other/"/>
    
    
      <category term="other" scheme="https://www.shadowerli.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>基于卷积的图片识别</title>
    <link href="https://www.shadowerli.com/2018/03/21/2018-3-22/"/>
    <id>https://www.shadowerli.com/2018/03/21/2018-3-22/</id>
    <published>2018-03-20T16:00:00.000Z</published>
    <updated>2018-12-11T13:39:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>这篇博客主要介绍通过Tesorflow来实现对图片的识别<br><a id="more"></a></excerpt></p><p>学习深度学习断断续续也将近半年了、从去年暑假接触tensorflow一步步从入门到放弃、又继续现在才算明白每一步做的是什么、本来想深入研究词向量分析做一个在线翻译的小项目和属于自己的siri（这一定非常cool）、在导师的建议下先从图像识别做起、语义模型的确太复杂了只能怪中国语言博大精深（笑死、、）可能做了一两年最终的结果将会出乎意料的喜感、不得不赞叹一下油管、、在线翻译实在是太强大了要是哪天能在谷歌工作就好了、不知不觉敲了好多废话、该写总结了<br>以下是写的很详细详细的链接、看不懂的可以再细细的看这个链接看个权重的动态图就行了、绝对精髓<br><a href="https://www.2cto.com/kf/201607/522441.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201607/522441.html</a></p><p>首先从输入的图片开始、mnist是28x28的单颜色通道的图片、训练时读取的是[batchsize,784]的数组、要转化为tensorflow卷积支持的输入格式[batchsize,28,28,1]、第二、三个表示几乘几的图片、最后一个表示颜色通道、这里为1因为是灰度图、接下来定义卷积的权重、就是你要定义一个移动的的过滤器来扫描这个图片以及若干个内核来存储扫描器与图片权值相乘再加上偏置值的一个结果、最终就可以得到卷积层的输出、需要定义的参数参考这篇博客十分的详细<br><a href="https://www.cnblogs.com/qggg/p/6832342.html" target="_blank" rel="noopener">https://www.cnblogs.com/qggg/p/6832342.html</a></p><p>卷积层得到输入后将其导入池化层、池化层大大减小了变量的个数（真的十分敬佩模型的创始人、真的太厉害了）、池化层也有类似的过滤器如果用的是max_pool相当于扫描一个区域、选出区域中最大的一个值输出、按照步长移动再扫描输出、从而最终达到简化参数的目的、池化层输出后将结果导入全连结层、然后就是固定的套路了、</p><p>具体代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mnist=input_data.read_data_sets(<span class="string">"MNIST_data"</span>,one_hot=<span class="keyword">True</span>)</span><br><span class="line">batch_size=<span class="number">100</span></span><br><span class="line">n_batch=mnist.train.num_examples//batch_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_init</span><span class="params">(shape)</span>:</span></span><br><span class="line">    init=tf.truncated_normal(shape=shape,stddev=<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(init)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_init</span><span class="params">(shape)</span>:</span></span><br><span class="line">    init=tf.constant(<span class="number">0.1</span>,shape=shape)</span><br><span class="line">    <span class="keyword">return</span>  tf.Variable(init)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(input,w)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.conv2d(input,w,strides=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],padding=<span class="string">'SAME'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(input,ksize=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],strides=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],padding=<span class="string">'SAME'</span>)</span><br><span class="line"></span><br><span class="line">x=tf.placeholder(tf.float32,[<span class="keyword">None</span>,<span class="number">784</span>])</span><br><span class="line">y=tf.placeholder(tf.float32,[<span class="keyword">None</span>,<span class="number">10</span>])</span><br><span class="line"><span class="comment">#全0填充从一开始移动</span></span><br><span class="line">input=tf.reshape(x,[<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#定义卷积的深度为32</span></span><br><span class="line"><span class="comment">#第一层卷积的输入[128,28,28,1]</span></span><br><span class="line">w_conv1=weight_init([<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">16</span>])</span><br><span class="line">b_conv1=weight_init([<span class="number">16</span>])</span><br><span class="line"><span class="comment">#定义的是same有0来填充每次管道的核心将会一次经过每个像素点</span></span><br><span class="line">conv1=tf.nn.relu(conv2d(input,w_conv1)+b_conv1)</span><br><span class="line"><span class="comment">#第一层卷积输出[128,28,28,16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#池化层只在指定的2，3维度上进行池化</span></span><br><span class="line"><span class="comment">#得到池化层的输出[128,14,14,16]</span></span><br><span class="line">pool1=pool(conv1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对应池化层的输出所以第三位为32此处定义深度为64</span></span><br><span class="line">w_conv2=weight_init([<span class="number">5</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">64</span>])</span><br><span class="line">b_conv2=weight_init([<span class="number">64</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#卷积的输出[128,14,14,64]</span></span><br><span class="line">conv2=tf.nn.relu(conv2d(pool1,w_conv2)+b_conv2)</span><br><span class="line"><span class="comment">#得到池化的最终输出[128,7,7,64]</span></span><br><span class="line">pool2=pool(conv2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义全连结层的权重</span></span><br><span class="line">weight=weight_init([<span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>,<span class="number">500</span>])</span><br><span class="line">bias=bias_init([<span class="number">500</span>])</span><br><span class="line"></span><br><span class="line">normal=tf.reshape(pool2,[<span class="number">-1</span>,<span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>])</span><br><span class="line"><span class="comment">#[-1,1024]</span></span><br><span class="line">output1=tf.nn.relu(tf.matmul(normal,weight)+bias)</span><br><span class="line">keep=tf.placeholder(tf.float32)</span><br><span class="line"><span class="comment">#定义dropout防止过拟合对提高准确率有很大的帮助</span></span><br><span class="line">drop=tf.nn.dropout(output1,keep)</span><br><span class="line"></span><br><span class="line">weight2=weight_init([<span class="number">500</span>,<span class="number">10</span>])</span><br><span class="line">bias2=bias_init([<span class="number">10</span>])</span><br><span class="line"><span class="comment">#最终得到的输出数组的每一个权值不一定是0，1、Softmax然后会正则化这些权重值、使它们的总和等于1、以此构造一个有效的概率分布</span></span><br><span class="line">prediction=tf.nn.softmax(tf.matmul(drop,weight2)+bias2)</span><br><span class="line"></span><br><span class="line">cross_entropy=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y,logits=prediction))</span><br><span class="line"><span class="comment">#这里用AdamOptimizer的效果要比梯度下降要好</span></span><br><span class="line">train_step=tf.train.AdamOptimizer(<span class="number">1e-4</span>).minimize(cross_entropy)</span><br><span class="line">correct_prediction=tf.equal(tf.arg_max(prediction,<span class="number">1</span>),tf.arg_max(y,<span class="number">1</span>))</span><br><span class="line">accuracy=tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">            batch_xs,batch_ys =mnist.train.next_batch(batch_size)</span><br><span class="line">            sess.run(train_step,feed_dict=&#123;x:batch_xs,y:batch_ys,keep:<span class="number">0.7</span>&#125;)</span><br><span class="line">        acc=sess.run(accuracy,feed_dict=&#123;x:mnist.test.images,y:mnist.test.labels,keep:<span class="number">1.0</span>&#125;)</span><br><span class="line">        print(<span class="string">'iter'</span>+str(epoch)+<span class="string">"  correct "</span>+str(acc))</span><br><span class="line">    input_image = mnist.train.images[<span class="number">11</span>:<span class="number">12</span>]</span><br><span class="line">    <span class="comment"># 可视化卷积层学习到的特征</span></span><br><span class="line">    <span class="comment"># 输入一张图片</span></span><br><span class="line">    cnn1=sess.run(w_conv1, feed_dict=&#123;x:input_image&#125;)</span><br><span class="line">    conv1_reshape = sess.run(tf.reshape(cnn1, [<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">16</span>]))</span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="comment"># 放在两行两列第一个位置#将舍去数组的后两位</span></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 将舍去数组的后两位</span></span><br><span class="line">    plt.imshow(conv1_reshape[:,:,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">    plt.title(<span class="string">'Conv1 16x28x28'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><h2 id="参数的计算"><a href="#参数的计算" class="headerlink" title="参数的计算"></a>参数的计算</h2><p>假设N<em>N为输入图像的size、F</em>F是filter(卷积核)的size、stride(即卷积核每次移动的像素)是滑动的步长。<br>那么一次卷积之后输出的第一个维度为(N-F)/stride +1</p><p>下面是一篇关于交叉熵的问题的博客<br><a href="http://blog.csdn.net/john_xyz/article/details/61211422" target="_blank" rel="noopener">http://blog.csdn.net/john_xyz/article/details/61211422</a><br>笔记本配置比较一般、渴望gpu来拯救、由于训练的比较慢又要不断调整参数最终准确率在97%以上是没问题的</p><h2 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h2><p>一般做图像识别用到的模型在github上都开源出来了、比如inception3就有基于Tensorflow的了、用inception3训练自己模型时卷积层的参数大致是不变的改变的是顶部神经元的参数<br>前面的操作差不多做的是特征提取、所以用自己的数据训练后得到的结果还是不错的、<br>下面是谷歌物体识别的连接、下面的模型可以拿来直接用不用自己一层一层搭网络、里面也有已经训练好的模型(当自己想要做点什么的时候谷歌都做好了、、、)<br><a href="https://github.com/tensorflow/models/tree/master/research/object_detection" target="_blank" rel="noopener">https://github.com/tensorflow/models/tree/master/research/object_detection</a><br>环境搭建推荐linux、windows的坑太多浪费了好长时间、官方给的教程十分精辟、要注意每次敲命令行要严格！！！对应注释中给的目录<br>最后还可以训练自己的数据集、教程官方github上也有、网上的教程也十分多参照一下就好了（不想再做验证性工作了）、、</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;这篇博客主要介绍通过Tesorflow来实现对图片的识别&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.shadowerli.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="cnn" scheme="https://www.shadowerli.com/tags/cnn/"/>
    
  </entry>
  
  <entry>
    <title>K-近邻算法Python实现</title>
    <link href="https://www.shadowerli.com/2018/01/30/2018-1-30/"/>
    <id>https://www.shadowerli.com/2018/01/30/2018-1-30/</id>
    <published>2018-01-29T16:00:00.000Z</published>
    <updated>2018-03-24T02:07:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>运用python通过计算距离来实现对某花的分类<br><a id="more"></a></excerpt></p><h2 id="算法解决的问题"><a href="#算法解决的问题" class="headerlink" title="算法解决的问题"></a>算法解决的问题</h2><p>已知样本集（此处的样本为某花的实例数据）、给定一未知样本的数据来断此样本的类别(此处为判断属于哪一类花）</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><p>特征抽取后计算出未知样本到所有已知样本的距离、根据给定参数K（最好为奇数便于投票）选出K个最近的样本点、统计出类别最多的样本点的类别、最终的的分类就是该类别<br>缺陷：数据的分布不均匀会导致结果的不准确<br>优化方法：根据距离的远近添加相应的权重来弱化数据分布不均匀的为题（下面代码还没实现权重的添加、、以后有空再加、、、）<br>个人脑洞：对于多维的数据、在二维分布上可能看不出任何规律、但在高维的空间中明显的可以分开好几个类别（如本例的某花数据在三维下就很明显了、还有支持向量机的划分方法太cool了）<br>此处的样本集（非常nice的数据集大全）<br><a href="http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data" target="_blank" rel="noopener">http://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data</a><br>样本集示例：前四列为花的数据、最后为花的类别</p><p>5.1,3.5,1.4,0.2,Iris-setosa</p><p>5.0,3.3,1.4,0.2,Iris-setosa</p><p>7.0,3.2,4.7,1.4,Iris-versicolor</p><p>4.6,3.1,1.5,0.2,Iris-setosa</p><p>6.4,3.2,5.3,2.3,Iris-virginica</p><p>6.9,3.2,5.7,2.3,Iris-virginica</p><p>4.6,3.4,1.4,0.3,Iris-setosa</p><p>代码实现如下：用测试集测试可以达到96%的准确率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入样本集list</span></span><br><span class="line"><span class="comment">#导入测试集计算测试集到每个样本集的距离,结果保存为list</span></span><br><span class="line"><span class="comment">#根据distance排名取k个投票选出最多的这个类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#传递时要第二个参数要为空参否则会共用同一个地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">(local)</span>:</span></span><br><span class="line">    dataset=[]</span><br><span class="line">    <span class="keyword">with</span> open(local) <span class="keyword">as</span> file2:</span><br><span class="line">        csv_reader = csv.reader(file2)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> csv_reader:</span><br><span class="line">            dataset.append(line)</span><br><span class="line">    <span class="keyword">return</span> dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span> <span class="params">(test,train)</span>:</span></span><br><span class="line">    result=<span class="number">0.0</span></span><br><span class="line">    <span class="comment">#此时每个test例如[1,2,3,4]每个train例如[1,2,3,4,a],-1除去标签</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span>  range(len(test)<span class="number">-1</span>):</span><br><span class="line">        result=result+math.sqrt(abs((float(test[i])-float(train[i]))*(float(test[i])+float(train[i]))))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(train,test,k=<span class="number">3</span>)</span>:</span></span><br><span class="line">    result=[]</span><br><span class="line">    sortresult=[]</span><br><span class="line">    <span class="comment">#计算每个样本集到样本的距离</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(test)):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(len(train)):</span><br><span class="line">            <span class="comment">#对于每个测试实例得到距离和对应的标签</span></span><br><span class="line">            result.append([distance(test[i],train[m]),train[m][<span class="number">-1</span>]])</span><br><span class="line">        sortresult.append(findsort(result,k))<span class="comment">#得到每一个测试集的分类结果</span></span><br><span class="line">        result=[]                            <span class="comment">#将每个测试集的距离集合清空</span></span><br><span class="line">    <span class="keyword">return</span> sortresult       <span class="comment">#最终结果</span></span><br><span class="line">    <span class="comment">#得到结果集，每一个test到样本集的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例输入[[3.917258917468777, 'Iris-setosa'], [4.365595716195167, 'Iris-setosa']]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findsort</span><span class="params">(data,k=<span class="number">3</span>)</span>:</span></span><br><span class="line">    result=&#123;&#125;</span><br><span class="line">    voat=[]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(len(data)):</span><br><span class="line">            result.update(&#123;data[x][<span class="number">0</span>]:data[x][<span class="number">1</span>]&#125;)</span><br><span class="line">    <span class="comment">#对字典进行排序从小到大</span></span><br><span class="line">    a=sorted(result.items(), key=<span class="keyword">lambda</span> d: d[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(k):</span><br><span class="line">         voat.append(a[m][<span class="number">-1</span>])</span><br><span class="line">    <span class="comment">#得到列表中出现次数最多的元素</span></span><br><span class="line">    b=Counter(voat).most_common(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> b[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算准确率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">correct</span><span class="params">(sample,predict)</span>:</span></span><br><span class="line">    flag=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(len(sample)):</span><br><span class="line">        <span class="keyword">if</span>(sample[a]==predict[a]):</span><br><span class="line">            flag=flag+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> flag/len(sample)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    testlist=[]</span><br><span class="line">    train=list(readfile(<span class="string">"F:\\train.csv"</span>))</span><br><span class="line">    test=list(readfile(<span class="string">"F:\\test.csv"</span>))</span><br><span class="line">    <span class="comment">#k为最近邻的个数</span></span><br><span class="line">    output=sort(train,test,<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#得到分类的结果集</span></span><br><span class="line">    print(output)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(len(test)):</span><br><span class="line">        testlist.append(test[a][<span class="number">-1</span>])</span><br><span class="line">    <span class="comment">#输出准确率</span></span><br><span class="line">    print(correct(testlist,output))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;运用python通过计算距离来实现对某花的分类&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.shadowerli.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://www.shadowerli.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基本神经网络</title>
    <link href="https://www.shadowerli.com/2017/12/10/2017-12-10/"/>
    <id>https://www.shadowerli.com/2017/12/10/2017-12-10/</id>
    <published>2017-12-09T16:00:00.000Z</published>
    <updated>2018-12-11T13:39:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>简单整理一下神经网络训练的步骤<br><a id="more"></a><br>总结一下最简单的神经网络的训练过程和原理<br>通常利用数据交叉验证来提高数据利用率<br><img src="http://aRootUser.github.io/img/2/1.jpg"><br>交叉验证：给定一个训练集和测试集，为了最大程度的利用测试集，可以将训练集分为若干份，这里为5。第一次将fold1(折)作为测试集其余的作为训练集，第二次将fold2作为测试集，其余的作为训练集，以此类推从而达到最大化利用数据更新权重的效果<br><img src="http://aRootUser.github.io/img/2/2.jpg"><br>对于输入的一张图片简单将图片的输入像素点看成[1,4]的矩阵、输出层为[1,3],中间的权值为[4,3]的矩阵、和图中不同图中是左成矩阵、这里定义的是右乘矩阵、没有定义中间层、最后还要加上[1,3]偏置值得到[1,3]的输出值每一个值代表某一类别的得分、<br><img src="http://aRootUser.github.io/img/2/3.jpg"><br>为了更好的定以中间权值定义的好坏以及预测结果的准确程度、用损失函数来衡量、损失函数最小表示预测越准确、这里定义的是svm损失函数、<br>l 表示自己定义的可容忍的长度<br>yi表示正确类别的得分<br>j表示其他类别的得分<br>通过计算每个其他类别减去正确类别的得分的最大值的求和来表是损失函数的结果对于多个输入例如输入100张图片还要除去100相当于取平均值<br><img src="http://aRootUser.github.io/img/2/4.jpg"><br>为了防止权值为0从而导致输入样本的每一个值没有被充分利用例如训练得到的两个权值<br>设输入的样本为[1,1,1,1]<br>权重W1[0.5,0.5,0.5,0.5]<br>权重W2[1,0,0,0]<br>矩阵相乘后得到的结果相同但是w2由于有三个0没有充分利用每一项所以添加w的平方项来惩罚权重为w2的情况、使其损失值变大<br><img src="http://aRootUser.github.io/img/2/5.jpg"><br><img src="http://aRootUser.github.io/img/2/6.jpg"><br>分类器的作用将输出的值通过sigmoid函数映射到0至1的区间上、e的x次幂进行放大、最后通过取其作为正确类别的概率取负对数得最终其对应的损失值(因为概率越大越输出的损失值越小)<br>前向传播：从输入的x一直到计算出loss、通过梯度下降算法找到一个下降方向、最终找到最低点、训练的批次数一般为2的整数次幂<br>一个Epoch表示迭代完所有数据、一个迭代表示跑完当前的一个batch</excerpt></p><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2><p>每次训练跟新权重的变化要乘一个学习率来调整权值变化的大小、过大会错过最优解</p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>通过计算出每一个权重对最终的loss值的影响来调整权重的大小(向前传播的逆向求解)</p><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>对神经元的输出进行去线性化、例如sigmoid函数(由于当x过大时很容易导致梯度消失使其无法求导进行反向传播、现在一般用relu激活函数并且求导简单）</p><h2 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h2><p>drop-out进行处理通过迭代来弥补神经网络的复杂度</p><h2 id="过程小结"><a href="#过程小结" class="headerlink" title="过程小结"></a>过程小结</h2><p>首先输入训练集如手写数字集、定义神经网络后、通过向前传播得到对每一个类别的输出、通过sortmax函数将输出转化为概率分布、通过与标签进行如下运算个（标签是one-hot概率）、将输出的概率分布取对数与标签值乘积在做平均值求和最后取负数-tf.reduce_sum(y_*tf.log(y))、得到交叉熵来反应结果集与标签的相似度、最后通过梯度下降法不断训练使交叉熵最小、来优化权重参数、</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;简单整理一下神经网络训练的步骤&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://www.shadowerli.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.shadowerli.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
